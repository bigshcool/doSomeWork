# C Primer Plus读书心得

## 1.使用多种整数类型的原因

​		为什么说short类型“可能”比int类型占用的空间少，long类型“可能”比int
类型占用的空间多？因为C语言只规定了short占用的存储空间不能多于int，
long占用的存储空间不能少于int。这样规定是为了适应不同的机器。例如，
过去的一台运行Windows 3的机器上，int类型和short类型都占16位，long类
型占32位。后来，Windows和苹果系统都使用16位储存short类型，32位储存
int类型和long类型（使用32位可以表示的整数数值超过20亿）。现在，计算
机普遍使用64位处理器，为了储存64位的整数，才引入了long long类型。

​		现在，个人计算机上最常见的设置是，long long占64位，long占32位，
short占16位，int占16位或32位（依计算机的自然字长而定）。原则上，这4
种类型代表4种不同的大小，但是在实际使用中，有些类型之间通常有重
叠。
​		C 标准对基本数据类型只规定了允许的最小大小。对于 16 位机，short
和 int 的最小取值范围是[−32767,32767]；

## 2.int类型的选择

​		int类型那么多，应该如何选择？首先，考虑unsigned类型。这种类型的
数常用于计数，因为计数不用负数。而且，unsigned类型可以表示更大的正
数。
​		如果一个数超出了int类型的取值范围，且在long类型的取值范围内时，
使用long类型。然而，对于那些long占用的空间比int大的系统，使用long类
型会减慢运算速度。因此，如非必要，请不要使用long类型。另外要注意一
点：如果在long类型和int类型占用空间相同的机器上编写代码，当确实需要
32位的整数时，应使用long类型而不是int类型，以便把程序移植到16位机后
仍然可以正常工作。类似地，如果确实需要64位的整数，应使用long long类
型。
​		如果在int设置为32位的系统中要使用16位的值，应使用short类型以节省
存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时，
才需要重点考虑节省空间的问题。使用short类型的另一个原因是，计算机中
某些组件使用的硬件寄存器是16位。

## 3. long常量和long long常量

​		通常，程序代码中使用的数字（如，2345）都被储存为int类型。如果使
用1000000这样的大数字，超出了int类型能表示的范围，编译器会将其视为
long int类型（假设这种类型可以表示该数字）。如果数字超出long可表示的
最大值，编译器则将其视为unsigned long类型。如果还不够大，编译器则将
其视为long long或unsigned long long类型（前提是编译器能识别这些类型）。
​		八进制和十六进制常量被视为int类型。如果值太大，编译器会尝试使用
unsigned int。如果还不够大，编译器会依次使用long、unsigned long、long
long和unsigned long long类型。
​		有些情况下，需要编译器以long类型储存一个小数字。例如，编程时要
显式使用IBM PC上的内存地址时。另外，一些C标准函数也要求使用long类
型的值。要把一个较小的常量作为long类型对待，可以在值的末尾加上l（小
写的L）或L后缀。使用L后缀更好，因为l看上去和数字1很像。因此，在int
为16位、long为32位的系统中，会把7作为16位储存，把7L作为32位储存。l
或L后缀也可用于八进制和十六进制整数，如020L和0x10L。
​		类似地，在支持long long类型的系统中，也可以使用ll或LL后缀来表示
long long类型的值，如3LL。另外，u或U后缀表示unsigned long long，如
5ull、10LLU、6LLU或9Ull。

## 4.打印short、long、long long和unsigned类型

​		打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使
用%ld转换说明。如果系统中int和long的大小相同，使用%d就行。但是，这
样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工
作。在x和o前面可以使用l前缀，%lx表示以十六进制格式打印long类型整
数，%lo表示以八进制格式打印long类型整数。注意，虽然C允许使用大写或
小写的常量后缀，但是在转换说明中只能用小写。
​		C语言有多种printf()格式。对于short类型，可以使用h前缀。%hd表示以
十进制显示short类型的整数，%ho表示以八进制显示short类型的整数。h和l
前缀都可以和u一起使用，用于表示无符号类型。例如，%lu表示打印
unsigned long类型的值。程序清单3.4演示了一些例子。对于支持long long类
型的系统，%lld和%llu分别表示有符号和无符号类型。

## 5.浮点数值上溢和下溢

​		会发生什么？这是一个上溢（overflow）的示例。当计算导致数字过
大，超过当前类型能表达的范围时，就会发生上溢。这种行为在过去是未定
义的，不过现在C语言规定，在这种情况下会给toobig赋一个表示无穷大的
特定值，而且printf()显示该值为inf或infinity（或者具有无穷含义的其他内
容）。

​		当除以一个很小的数时，情况更为复杂。回忆一下，float类型的数以指
数和尾数部分来储存。存在这样一个数，它的指数部分是最小值，即由全部
可用位表示的最小尾数值。该数字是float类型能用全部精度表示的最小数
字。现在把它除以 2。通常，这个操作会减小指数部分，但是假设的情况
中，指数已经是最小值了。所以计算机只好把尾数部分的位向右移，空出第
1 个二进制位，并丢弃最后一个二进制数。以十进制为例，把一个有4位有
效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。虽然得
到了结果，但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫
作下溢（underflow）。C语言把损失了类型全精度的浮点值称为低于正常的
（subnormal）浮点值。因此，把最小的正浮点数除以 2将得到一个低于正常
的值。如果除以一个非常大的值，会导致所有的位都为0。

​		另一个特殊的浮点值NaN（not a number的缩写）。例如，给asin()

函数传递一个值，该函数将返回一个角度，该角度的正弦就是传入函数的
值。但是正弦值不能大于1，因此，如果传入的参数大于1，该函数的行为是
未定义的。在这种情况下，该函数将返回NaN值，printf()函数可将其显示为
nan、NaN或其他类似的内容

## 6.刷新输出

​		printf()何时把输出发送到屏幕上？最初，printf()语句把输出发送到一个
叫作缓冲区（buffer）的中间存储区域，然后缓冲区中的内容再不断被发送
到屏幕上。C 标准明确规定了何时把缓冲区中的内容发送到屏幕：当缓冲区
满、遇到换行字符或需要输入的时候（从缓冲区把数据发送到屏幕或文件被
称为刷新缓冲区）。例如，前两个 printf()语句既没有填满缓冲区，也没有
换行符，但是下一条 scanf()语句要求用户输入，这迫使printf()的输出被发送
到屏幕上。
​		旧式编译器遇到scanf()也不会强行刷新缓冲区，程序会停在那里不显示
任何提示内容，等待用户输入数据。在这种情况下，可以使用换行字符刷新
缓冲区。代码应改为：
​		printf("Enter your desired monthly salary:\n");
​		scanf("%f", &salary);
​		无论接下来的输入是否能刷新缓冲区，代码都会正常运行。这将导致光
标移至下一行起始处，用户无法在提示内容同一行输入数据。还有一种刷新



