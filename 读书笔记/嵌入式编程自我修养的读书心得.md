# 嵌入式编程自我修养的读书心得

## 1. 程序的编译、链接、安装和运行

​		在 Windows 下 开 发 一 个 C 程 序， 一 般 都 会 用 到 集 成 开 发 环 境 （Integrated Development Environment，IDE），如VC++6.0、C-Free、Visual Studio、Keil等。IDE 界面友好，使用方便，5分钟就可以快速上手：新建一个工程/源文件，编辑程序，点击界面上的Run按钮，然后我们编写的程序就可以运行了。至于程序是如何编译和运行的，我们无须操心，因为IDE已经为我们封装好了：IDE集程序编辑器、工程管理器、编器汇编器、链接器、调试器、二进制工具、库、头文件于一身，留给用户的使用接口就是创建一个工程，编写代码，运行代码。这种一站式开发方式大大简化了软件的开发，程序员只需要关注自己要实现的业务逻辑和功能代码即可，至于底层是如何编译运行的，不用关心。

​		嵌入式开发和桌面开发不太一样：处理器平台和软件生态碎片化、多样化。为了提高性价比，不同的嵌入式系统往往采取更灵活的配置：不同的CPU平台、不同大小的存储、不同的启动方式，导致我们在编译程序时，有时候不仅要考虑一个嵌入式平台的内存、存储器的地址空间，还要考虑将我们的程序代码“烧”写到什么地方、加载到内存什么地方、如何执行。这就要求嵌入式工程师必须了解在程序运行的背后，它们是如何编译、链接和运行的。有了这些理论支撑，我们才可能灵活地根据硬件平台的差异去完成软件层面的编译优化和配置。

### 1.1 从源程序到二进制文件

​		程序的编译过程，其实就是将我们编写的C源程序翻译成CPU能够识别和运行的二进制机器指令的过程。关于C程序我们已经很熟悉了：一个C程序主要由一行行C语言语句组成，不同的语句构成一个个代码块或函数，每个语句由C语言的关键字、运算符、预处理命令、用户定义的变量名、函数名等很多token构成。一个C语言项目通
常由多个文件组成，生成的二进制可执行文件默认是a.out。

​		readelf-h命令主要用来获取可执行文件的头部信息，主要包括可执行文件运行的平台、软件版本、程序入口地址，以及program headers、section header等信息。通过文件的头部信息，我们可以知道在a.out可执行文件里一共有多少个section headers。它主要用来描述可执行文件的section信息，一个可执行文件通常由不同的段（section）构成：代码段、数据段、BSS段、只读数据段等。每个section用一个section header来描述，包括段名、段的类型、段的起始地址、段的偏移和段的大小等。一个可执行文件中的每一个section都有一个section header，将这些section headers集中放到一起，就是section header table，翻译成中文就是节头表。我们可以使用readelf-S命令来查看一个可执行文件的节头表。

在一个可执行文件中，我们比较熟悉的section有.text、.data、.bss，就是我们常说的代码段、数据段、BSS段。C程序中定义的函数、变量、未初始化的全局变量经过编译后会放置在不同的段中：函数翻译成二进制指令放在代码段中，初始化的全局变量和静态局部变量放在数据段中。**BSS段比较特殊，一般来讲，未初始化的全局变量和静态变量会放置在BSS段中，但是因为它们未初始化，默认值全部是0，其实没有必要再单独开辟空间存储，为了节省存储空间，所以在可执行文件中BSS段是不占用空间的。但是BSS段的大小、起始地址和各个变量的地址信息会分别保存在节头表sectionheader table和符号表.symtab里，当程序运行时，加载器会根据这些信息在内存中紧挨
着数据段的后面为BSS段开辟一片存储空间，为各个变量分配存储单元。**

​		**从C程序到可执行文件，整个编译过程并不是一气呵成、一步完成的，而是环环相扣、多步执行的**。如图4-3所示，程序的整个编译流程主要分为以下几个阶段：预处理、编译、汇编、链接。每个阶段需要调用不同的工具去完成，上一阶段的输出作为下一阶段的输入，步步推进。

![](https://raw.githubusercontent.com/bigshcool/myPic/main/202207271106673.png)

​		在一个多文件的C项目中，编译器是以C源文件为单位进行编译的。在编译的不同阶段，编译程序（如gcc、arm-linux-gcc）会调用不同的工具来完成不同阶段的任务。在编译器安装路径的bin目录下，你会看到各种各样的编译工具，gcc在程序编译过程中会分别调用它们，常见的工具有预处理器、编译器、汇编器、链接器。

- 预处理器：将源文件main.c经过预处理变为main.i。

- 编译器：将预处理后的main.i编译为汇编文件main.s。

- 汇编器：将汇编文件main.s编译为目标文件main.o。

- 链接器：将各个目标文件main.o、sub.o链接成可执行文件a.out。

  最后生成的可执行文件a.out其实也是目标文件（object file），唯一不同的是，a.out是一种可执行的目标文件。目标文件一般可以分为3种。

- 可重定位的目标文件（relocatable files）。

-  可执行的目标文件（executable files）。

- 可被共享的目标文件（shared object files）。

### 1.2 预处理过程

​		为了方便编程，编译器一般为开发人员提供一些预处理命令，使用＃标识。我们常见的预处理命令如下。

- 头文件包含：#include
- 定义一个宏：#define
- 条件编译:#if,#else,#endif
- 编译控制:#pragma

通过头文件包含可以实现模块化编程；使用宏可以定义一个常量，提高程序的可读性；通过条件编译可以让代码兼容不同的处理器架构和平台，以最大限度地复用公用代码。通过＃pragma预处理命令可以设定编译器的状态，指示编译器完成一些特定的动作。

- #pragma pack([n])：指示结构体和联合成员的对齐方式。
- #pragma message("string")：在编译信息输出窗口打印自己的文本信息。
- #pragma warning:有选择地改变编译器的警告信息行为
- #pragma once:在头文件中添加这条命令，可以防止头文件多次编译。

​        预处理过程，其实就是在编译源程序之前，先处理源文件中的各种预处理命令。编译器是不认识预处理指令的，在编译之前不先把这些预处理命令处理掉，编译器就会报错。预处理主要包括以下操作

- 头文件展开：将#include包含的头文件内容展开到当前位置。
- 宏展开：展开所有的宏定义，并删除#define
- 条件编译：根据宏定义条件，选择要参与编译的分支代码，其余的分支丢弃。
- 删除注释
- 添加行号和文件名标识：编译过程中根据需要可以显示这些信息。
- 保留#pragma命令：该命令会在程序编译时指令编译器执行一些特定行为。

### 1.3 程序的编译

​		经过预处理后的源文件，退去一切包装，注释被删除，各种预处理命令也基本上被处理掉，剩下的就是原汁原味的C代码了。接下来的第二步，就开始进入编译阶段。编译阶段主要分两步：

- 第一步，编译器调用一系列解析工具，去分析这些C代码，将C源文件编译为汇编文件
- 第二步，通过汇编器将汇编文件汇编成可重定位的目标文件

​        从C文件到汇编文件，其实就是从高级语言到低级语言的转换。通过前面的学习我们知道，一个汇编文件是以段为单位来组织程序的：代码段、数据段、BSS段等，各个段之间相互独立。

​		汇编程序的组织结构和二进制目标文件已经很接近了。没错，两者本质上其实就是等价的，汇编指令就是二进制指令的助记符，唯一的差异就是汇编语言的程序结构需要使用各种伪操作来组织。汇编文件经过汇编器汇编后，处理掉各种伪操作命令，就是二进制目标文件了。总体而言，编译过程可以分下以下六步。

- 词法分析

  ​		词法分析是编译过程的第一步，主要用来解析C程序语句。词法分析一般会通过词法扫描器从左到右，一个字符一个字符地读入源程序，通过有限状态机解析并识别这些字符流，将源程序分解为一系列不能再分解的记号单元——token。

  ​		token是字符流解析过程中有意义的最小记号单元，常见的token如下。

  - C语言的各种关键字：int、float、for、while、break等。
  - 用户定义的各种标识符：函数名、变量名、标号等。
  - 字面量：数字、字符串等。
  - 运算符：C语言标准定义的40多个运算符。
  - 分隔符：程序结束符分号、for循环中的逗号等。

- 语法分析

  ​		词法分析结束后，接着进行语法分析。语法分析主要是对前一阶段产生的token序列进行解析，看是否能构建成一个语法上正确的语法短语（程序、语句、表达式等）。语法短语用语法树表示，是一种树型结构，不再是线性序列。

  ​		语法分析工具在对token序列分析过程中，如果发现不能构建语法上正确的语句或
  表达式，就会报语法错误：syntax error。

- 语义分析

  ​		语法分析仅仅对程序做语法检查，对程序、语句的真正意义并不了解，而语义分析主要对语
  法分析输出的各种表达式、语句进行检查，看看有没有错误。

  ```c
  \\ 语法分析
  i = 10; \\正确
  
  \\ 语义分析
  i = 10; \\错误，因为结合上下文没有进行变量声明
  ```

  ​		如果你传递给函数的实参与函数声明的形参类型不匹配，或者你使用了一个未声明的变量，或者除数为零了，break在循环语句或switch语句之外出现了，或者在循环语句之外发现了continue语句，一般都会报语义上的错误或警告。

- 中间代码和目标代码生成

  ​		生成中间代码。在语法分析阶段输出的表达式或程序语句，还是以语法树的形式存储，我们需要将其转换为中间代码。中间代码是编译过程中的一种临时代码，常见的有三地址码、P-代码等。

  ​		中间代码和语法树相比，有很多优点：**中间代码是一维线性序列结构，类似伪代码，编译器很容易将中间代码翻译成目标代码。如上面的表达式语句**。

  ​        **中间码一般和平台是无关的**，如果你想将C程序编译为X86平台下的可执行文件，那么最后一步就是根据X86指令集，将中间代码翻译为X86汇编程序；如果你想编译成在ARM平台上运行的可执行文件，那么就要参考ARM指令集，根据ATPCS规则分配寄存器，将中间代码翻译成ARM汇编程序。

- 汇编代码生成

  ​		汇编过程是使用汇编器将前一阶段生成的汇编文件翻译成目标文件。汇编器的主要工作就是参考ISA指令集，将汇编代码翻译成对应的二进制指令，同时生成一些必要的信息，以section的形式组装到目标文件中，后面的链接过程会用到这些信息。

  ​       main.c，经过编译阶段后，会生成对应的main.o目标文件。main.o是不可执行的，属于可重定位的目标文件，它们要经过链接器重定位、链接之后，才能组装成一个可执行的目标文件a.out。

  ​		通过编译生成的可重定位目标文件，都是以零地址为链接起始地址进行链接的。**也就是说，编译器在将源文件翻译成可重定位目标文件的过程中，将不同的函数编译成二进制指令后，是从零地址开始依次将每一个函数的指令序列存放到代码段中，每个函数的入口地址也就从零地址开始依次往后偏移。我们使用readelf命令分析main.o这个目标文件。**

  ```sh
  readelf -S main.o
  ```

  ​		通过打印以零地址为基址进行代码段的组装。在每个可重定位目标文件中，函数或变量的地址其实就是它们在文件中相对于零地址的偏移。在每个可重定位目标文件中，函数或变量的地址其实就是它们在文件中相对于零地址的偏移。每个目标文件都是这样。

  ​		**那么问题出来，每个可重定位的目标文件的地址都是0开始的，在文件链接的过程汇总，连接器在将各个目标文件组装在一块时，各个目标文件的起始地址就发生了改变，那么这个目标文件内的函数或变量地址也要随之更新，否则就无法通过函数名去引用函数，无法通过变量名去引用变量。**

  ​		很简单，链接器将各个目标文件组装在一起后，我们需要重新修改各个目标文件中的变量或函数的地址，这个过程一般称为重定位。一个项目中有那么多文件，编译生成了那么多目标文件，链接器如何知道哪些函数或变量需要重定位呢？**很简单，我们把需要重定位的符号收集起来，生成一个重定位表**，以section的形式保存到每个可重定位目标文件中就可以了。



​		









