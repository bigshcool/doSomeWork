# 嵌入式编程自我修养的读书心得

## 1. 程序的编译、链接、安装和运行

​		在 Windows 下 开 发 一 个 C 程 序， 一 般 都 会 用 到 集 成 开 发 环 境 （Integrated Development Environment，IDE），如VC++6.0、C-Free、Visual Studio、Keil等。IDE 界面友好，使用方便，5分钟就可以快速上手：新建一个工程/源文件，编辑程序，点击界面上的Run按钮，然后我们编写的程序就可以运行了。至于程序是如何编译和运行的，我们无须操心，因为IDE已经为我们封装好了：IDE集程序编辑器、工程管理器、编器汇编器、链接器、调试器、二进制工具、库、头文件于一身，留给用户的使用接口就是创建一个工程，编写代码，运行代码。这种一站式开发方式大大简化了软件的开发，程序员只需要关注自己要实现的业务逻辑和功能代码即可，至于底层是如何编译运行的，不用关心。

​		嵌入式开发和桌面开发不太一样：处理器平台和软件生态碎片化、多样化。为了提高性价比，不同的嵌入式系统往往采取更灵活的配置：不同的CPU平台、不同大小的存储、不同的启动方式，导致我们在编译程序时，有时候不仅要考虑一个嵌入式平台的内存、存储器的地址空间，还要考虑将我们的程序代码“烧”写到什么地方、加载到内存什么地方、如何执行。这就要求嵌入式工程师必须了解在程序运行的背后，它们是如何编译、链接和运行的。有了这些理论支撑，我们才可能灵活地根据硬件平台的差异去完成软件层面的编译优化和配置。

### 1.1 从源程序到二进制文件

​		程序的编译过程，其实就是将我们编写的C源程序翻译成CPU能够识别和运行的二进制机器指令的过程。关于C程序我们已经很熟悉了：一个C程序主要由一行行C语言语句组成，不同的语句构成一个个代码块或函数，每个语句由C语言的关键字、运算符、预处理命令、用户定义的变量名、函数名等很多token构成。一个C语言项目通
常由多个文件组成，生成的二进制可执行文件默认是a.out。

​		readelf-h命令主要用来获取可执行文件的头部信息，主要包括可执行文件运行的平台、软件版本、程序入口地址，以及program headers、section header等信息。通过文件的头部信息，我们可以知道在a.out可执行文件里一共有多少个section headers。它主要用来描述可执行文件的section信息，一个可执行文件通常由不同的段（section）构成：代码段、数据段、BSS段、只读数据段等。每个section用一个section header来描述，包括段名、段的类型、段的起始地址、段的偏移和段的大小等。一个可执行文件中的每一个section都有一个section header，将这些section headers集中放到一起，就是section header table，翻译成中文就是节头表。我们可以使用readelf-S命令来查看一个可执行文件的节头表。

在一个可执行文件中，我们比较熟悉的section有.text、.data、.bss，就是我们常说的代码段、数据段、BSS段。C程序中定义的函数、变量、未初始化的全局变量经过编译后会放置在不同的段中：函数翻译成二进制指令放在代码段中，初始化的全局变量和静态局部变量放在数据段中。**BSS段比较特殊，一般来讲，未初始化的全局变量和静态变量会放置在BSS段中，但是因为它们未初始化，默认值全部是0，其实没有必要再单独开辟空间存储，为了节省存储空间，所以在可执行文件中BSS段是不占用空间的。但是BSS段的大小、起始地址和各个变量的地址信息会分别保存在节头表sectionheader table和符号表.symtab里，当程序运行时，加载器会根据这些信息在内存中紧挨
着数据段的后面为BSS段开辟一片存储空间，为各个变量分配存储单元。**

​		**从C程序到可执行文件，整个编译过程并不是一气呵成、一步完成的，而是环环相扣、多步执行的**。如图4-3所示，程序的整个编译流程主要分为以下几个阶段：预处理、编译、汇编、链接。每个阶段需要调用不同的工具去完成，上一阶段的输出作为下一阶段的输入，步步推进。

![](https://raw.githubusercontent.com/bigshcool/myPic/main/202207271106673.png)

​		在一个多文件的C项目中，编译器是以C源文件为单位进行编译的。在编译的不同阶段，编译程序（如gcc、arm-linux-gcc）会调用不同的工具来完成不同阶段的任务。在编译器安装路径的bin目录下，你会看到各种各样的编译工具，gcc在程序编译过程中会分别调用它们，常见的工具有预处理器、编译器、汇编器、链接器。

- 预处理器：将源文件main.c经过预处理变为main.i。

- 编译器：将预处理后的main.i编译为汇编文件main.s。

- 汇编器：将汇编文件main.s编译为目标文件main.o。

- 链接器：将各个目标文件main.o、sub.o链接成可执行文件a.out。

  最后生成的可执行文件a.out其实也是目标文件（object file），唯一不同的是，a.out是一种可执行的目标文件。目标文件一般可以分为3种。

- 可重定位的目标文件（relocatable files）。

-  可执行的目标文件（executable files）。

- 可被共享的目标文件（shared object files）。

### 1.2 预处理过程

​		为了方便编程，编译器一般为开发人员提供一些预处理命令，使用＃标识。我们常见的预处理命令如下。

- 头文件包含：#include
- 定义一个宏：#define
- 条件编译:#if,#else,#endif
- 编译控制:#pragma

通过头文件包含可以实现模块化编程；使用宏可以定义一个常量，提高程序的可读性；通过条件编译可以让代码兼容不同的处理器架构和平台，以最大限度地复用公用代码。通过＃pragma预处理命令可以设定编译器的状态，指示编译器完成一些特定的动作。

- #pragma pack([n])：指示结构体和联合成员的对齐方式。
- #pragma message("string")：在编译信息输出窗口打印自己的文本信息。
- #pragma warning:有选择地改变编译器的警告信息行为
- #pragma once:在头文件中添加这条命令，可以防止头文件多次编译。

​        预处理过程，其实就是在编译源程序之前，先处理源文件中的各种预处理命令。编译器是不认识预处理指令的，在编译之前不先把这些预处理命令处理掉，编译器就会报错。预处理主要包括以下操作

- 头文件展开：将#include包含的头文件内容展开到当前位置。
- 宏展开：展开所有的宏定义，并删除#define
- 条件编译：根据宏定义条件，选择要参与编译的分支代码，其余的分支丢弃。
- 删除注释
- 添加行号和文件名标识：编译过程中根据需要可以显示这些信息。
- 保留#pragma命令：该命令会在程序编译时指令编译器执行一些特定行为。

### 1.3 程序的编译

​		经过预处理后的源文件，退去一切包装，注释被删除，各种预处理命令也基本上被处理掉，剩下的就是原汁原味的C代码了。接下来的第二步，就开始进入编译阶段。编译阶段主要分两步：

- 第一步，编译器调用一系列解析工具，去分析这些C代码，将C源文件编译为汇编文件
- 第二步，通过汇编器将汇编文件汇编成可重定位的目标文件

​        从C文件到汇编文件，其实就是从高级语言到低级语言的转换。通过前面的学习我们知道，一个汇编文件是以段为单位来组织程序的：代码段、数据段、BSS段等，各个段之间相互独立。

​		汇编程序的组织结构和二进制目标文件已经很接近了。没错，两者本质上其实就是等价的，汇编指令就是二进制指令的助记符，唯一的差异就是汇编语言的程序结构需要使用各种伪操作来组织。汇编文件经过汇编器汇编后，处理掉各种伪操作命令，就是二进制目标文件了。总体而言，编译过程可以分下以下六步。

- 词法分析

  ​		词法分析是编译过程的第一步，主要用来解析C程序语句。词法分析一般会通过词法扫描器从左到右，一个字符一个字符地读入源程序，通过有限状态机解析并识别这些字符流，将源程序分解为一系列不能再分解的记号单元——token。

  ​		token是字符流解析过程中有意义的最小记号单元，常见的token如下。

  - C语言的各种关键字：int、float、for、while、break等。
  - 用户定义的各种标识符：函数名、变量名、标号等。
  - 字面量：数字、字符串等。
  - 运算符：C语言标准定义的40多个运算符。
  - 分隔符：程序结束符分号、for循环中的逗号等。

- 语法分析

  ​		词法分析结束后，接着进行语法分析。语法分析主要是对前一阶段产生的token序列进行解析，看是否能构建成一个语法上正确的语法短语（程序、语句、表达式等）。语法短语用语法树表示，是一种树型结构，不再是线性序列。

  ​		语法分析工具在对token序列分析过程中，如果发现不能构建语法上正确的语句或
  表达式，就会报语法错误：syntax error。

- 语义分析

  ​		语法分析仅仅对程序做语法检查，对程序、语句的真正意义并不了解，而语义分析主要对语
  法分析输出的各种表达式、语句进行检查，看看有没有错误。

  ```c
  \\ 语法分析
  i = 10; \\正确
  
  \\ 语义分析
  i = 10; \\错误，因为结合上下文没有进行变量声明
  ```

  ​		如果你传递给函数的实参与函数声明的形参类型不匹配，或者你使用了一个未声明的变量，或者除数为零了，break在循环语句或switch语句之外出现了，或者在循环语句之外发现了continue语句，一般都会报语义上的错误或警告。

- 中间代码和目标代码生成

  ​		生成中间代码。在语法分析阶段输出的表达式或程序语句，还是以语法树的形式存储，我们需要将其转换为中间代码。中间代码是编译过程中的一种临时代码，常见的有三地址码、P-代码等。

  ​		中间代码和语法树相比，有很多优点：**中间代码是一维线性序列结构，类似伪代码，编译器很容易将中间代码翻译成目标代码。如上面的表达式语句**。

  ​        **中间码一般和平台是无关的**，如果你想将C程序编译为X86平台下的可执行文件，那么最后一步就是根据X86指令集，将中间代码翻译为X86汇编程序；如果你想编译成在ARM平台上运行的可执行文件，那么就要参考ARM指令集，根据ATPCS规则分配寄存器，将中间代码翻译成ARM汇编程序。

- 汇编代码生成

  ​		汇编过程是使用汇编器将前一阶段生成的汇编文件翻译成目标文件。汇编器的主要工作就是参考ISA指令集，将汇编代码翻译成对应的二进制指令，同时生成一些必要的信息，以section的形式组装到目标文件中，后面的链接过程会用到这些信息。

  ​       main.c，经过编译阶段后，会生成对应的main.o目标文件。main.o是不可执行的，属于可重定位的目标文件，它们要经过链接器重定位、链接之后，才能组装成一个可执行的目标文件a.out。

  ​		通过编译生成的可重定位目标文件，都是以零地址为链接起始地址进行链接的。**也就是说，编译器在将源文件翻译成可重定位目标文件的过程中，将不同的函数编译成二进制指令后，是从零地址开始依次将每一个函数的指令序列存放到代码段中，每个函数的入口地址也就从零地址开始依次往后偏移。我们使用readelf命令分析main.o这个目标文件。**

  ```sh
  readelf -S main.o
  ```

  ​		通过打印以零地址为基址进行代码段的组装。在每个可重定位目标文件中，函数或变量的地址其实就是它们在文件中相对于零地址的偏移。在每个可重定位目标文件中，函数或变量的地址其实就是它们在文件中相对于零地址的偏移。每个目标文件都是这样。

  ​		**那么问题出来，每个可重定位的目标文件的地址都是0开始的，在文件链接的过程汇总，连接器在将各个目标文件组装在一块时，各个目标文件的起始地址就发生了改变，那么这个目标文件内的函数或变量地址也要随之更新，否则就无法通过函数名去引用函数，无法通过变量名去引用变量。**

  ​		很简单，链接器将各个目标文件组装在一起后，我们需要重新修改各个目标文件中的变量或函数的地址，这个过程一般称为重定位。一个项目中有那么多文件，编译生成了那么多目标文件，链接器如何知道哪些函数或变量需要重定位呢？**很简单，我们把需要重定位的符号收集起来，生成一个重定位表**，以section的形式保存到每个可重定位目标文件中就可以了。

## 1.4 链接过程

​		在一个C项目的编译中，编译器以C源文件为单位，将一个个C文件翻译成对应的目标文件。生成的每一个目标文件都是由代码段、数据段、BSS段、符号表等section组成的。这些section从目标文件的零偏移地址开始按照顺序依次排放，每个段中的符号相对于零地址的偏移，其实就是每个符号的地址，**这样程序中定义的变量、函数名等，都有了一个暂时的地址。**

​		**在链接的过程中这些暂时的地址会被重新拆分，每个section的起始参考地址都会发生变化，导致session中定义的函数、全局变量也要随之发生变化，需要重新修订即重定位**，这些函数、全局变量等符号会同时被编译器收集起来放置在目标文件中。这些目标文件是不可执行的，他们需要连接器链接、重定位才能够运行。**链接过程:分段组装、符号决议和重定位**

- 分段组装

  ​		链接过程的第一步，就是将各个目标文件分段组装。链接器将编译器生成的各个可重定位目标文件重新分解组装：将各个目标文件的代码段放在一起，作为最终生成的可执行文件的代码段；将各个目标文件的数据段放在一起，作为可执行文件的数据段。其他section也会按照同样的方法进行组装。

  ​        除了代码段、数据段的分解组装需要关注，还有一个重要的section需要我们了解一下：符号表。**链接器会在可执行文件中创建一个全局的符号表**，收集各个目标文件符号表中的符号，然后将其统一放到全局符号表中。通过这步操作，一个可执行文件中的所有符号都有了自己的地址，并保存在全局符号表中，但此时全局符号表中的地址还都是原来在各个目标文件中的地址，即相对于零地址的偏移。

  ​        在链接过程中，不同的代码段如何组装？这也是很讲究的。链接生成的可执行文件最终是要被加载到内存中执行的，那么要加载到内存中的什么地方呢。**一般来讲，程序在链接程序时需要指定一个链接起始地址，链接开始地址一般也就是程序要加载到内存中的地址**。在链接过程中，各个段在可执行文件中的先后组装顺序也是一个需要考虑的问题，一个可执行程序肯定会有入口地址的，一般先执行的代码要放到前面。那么如何指定程序的链接地址和各个段的组装顺序呢？很简单，通过链接脚本就可以了。链接脚本本质上是一个脚本文件。在这个脚本文件里，不仅规定了各个段的组装顺序、起始地址、位置对齐等信息，同时对输出的可执行文件格式、运行平台、入口地址等信息做了详细的描述。链接器就是根据链接脚本定义的规则来组装可执行文件的，并最终将这些信息以section的形式保存到可执行文件的ELF Header中。

  ​		假如在一个嵌入式系统中，内存RAM的起始地址是0x60000000，我们在链接程序时，就可以在链接脚本中指定内存中的一个合法地址作为链接起始地址。程序运行时，加载器首先会解析可执行文件中的ELF Header头部信息，验证程序的运行平台和加载地址信息，然后将可执行文件加载到内存中对应的地址，程序就可以正常运行了。

  ​		在嵌入式裸机环境下编译程序，尤其是编译ARM底层代码，很多时候我们要根据开发版的不同硬件配置、内存大小和地址，灵活指定链接地址，或者显示指定链接脚本，有时候甚至自己编写链接脚本。

  ​		不同的编译器、不同的操作系统，链接脚本的文件名后缀一般也不一样。GCC编译器的默认链接脚本在/usr/lib/scripts目录下，而C-Free集成开发环境的默认链接脚本则在安装路径下的mingw/mingw32/lib/ldscripts下。
  ​        不同的编译器默认的链接地址也是不一样的，如笔者在Ubuntu 16.04环境下安装的32位GCC编译器，默认链接起始地址为0x08048000，32位ARM交叉编译器的默认链接起始地址0x10000。在一个由带有MMU的CPU搭建的嵌入式系统中，程序的链接起始地址往往都是一个虚拟地址，程序运行过程中还需要地址转换，通过MMU将虚拟地址转换为物理地址，然后才能访问内存，这部分内容属于CPU硬件底层要关心的内容，和编译原理是不冲突的。

- 符号决议

  ​		一个公司的项目通常由多人组成的软件团队共同开发。一个项目一般由产品经理定义功能需求，由架构师进行系统分析和模块划分，然后将各个模块的具体实现分配给不同的人员。开发人员在实现各自模块的编程中，**可能会产生一个问题：位于不同模块或不同文件中的全局变量、函数可能存在重名冲突。**

  ​		链接器早就料到会有这种情况，它有专门的符号决议规则来解决这种符号冲突。

  ​		编译器为了解决这种符号冲突，引入了强符号和弱符号的概念：函数名、初始化的全局变量是强符号，而未初始化的全局变量则是弱符号。有了强符号和弱符号的概念后，再理解上面的三句话就比较清晰了：在一个多文件的工程中，强符号不允许多次定义，否则就会发生重定义错误。强符号和弱符号可以在一个项目中共存，**当强弱符号共存时，强符号会覆盖掉弱符号，链接器会选择强符号作为可执行文件中的最终符号。**

  ​		链接器也允许一个项目中出现多个弱符号共存。在程序编译期间，编译器在分析每个文件中未初始化的全局变量时，并不知道该符号在链接阶段是被采用还是被丢弃，因此在程序编译期间，未初始化的全局变量并没有被直接放置在BSS段中，而是将这些弱符号放到一个叫作COMMON的临时块中，在符号表中使用一个未定义的COMMON来标记，在目标文件中也没有给它们分配存储空间。

  ​	 	**在链接期间，链接器会比较多个文件中的弱符号，选择占用空间最大的那一个，作为可执行文件中的最终符号，此时弱符号的大小已经确定，并被直接放到了可执行文件的BSS段中。**

  ​		**正常情况下，初始化的全局变量、函数名默认都是强符号，未初始化的全局变量默认是弱符号。如果在项目中有特殊需求，我们也可以将一些强符号显式转化为弱符号。**

  ​		和强符号、弱符号对应的，还有强引用、弱引用的概念。在一个程序中，我们可以定义多个函数和变量，变量名和函数名都是符号，这些符号的本质，或者说这些符号值，其实就是地址。在另一个文件中，我们可以通过函数名去调用该函数，通过变量名去访问该变量。我们通过符号去调用一个函数或访问一个变量，通常称之为引用（reference），**强符号对应强引用，弱符号对应弱引用**

  ​		利用链接器对弱引用的处理规则:**我们在引用一个符号之前可以先判断该符号是否存在（定义）**。这样做的好处是：当我们引用一个未定义符号时，在链接阶段不会报错，在运行阶段通过判断运行，也可以避免运行错误。举个例子，如果我们想实现一个视频解码模块，并最终封装成库的形式提供给应用程序开发者使用。在模块实现的过程中，我们可以将提供给用户的一系列API函数声明为弱符号，这样做有两个好处：一是当我们对库中的某些API函数的实现不是很满意，或者这些API存在bug，我们有更好的实现时，可以自定义与库函数同名的函数，直接调用它们而不会发生冲突。二是在库的实现过程中，我们可以将某些扩展功能模块中还未完成的一些API定义为弱引用。应用程序在调用这些API之前，要先判断该函数是否实现，然后才调用运行。这样做的好处就是未来发布新版本库时，无论这些接口是否已经实现，或者已经删除，都不会影响应用程序的正常链接和运行。

  

  ​		

  ​		

  ​		





​		









