

# 嵌入式编程自我修养的读书心得

## 1. 程序的编译、链接、安装和运行

​		在 Windows 下 开 发 一 个 C 程 序， 一 般 都 会 用 到 集 成 开 发 环 境 （Integrated Development Environment，IDE），如VC++6.0、C-Free、Visual Studio、Keil等。IDE 界面友好，使用方便，5分钟就可以快速上手：新建一个工程/源文件，编辑程序，点击界面上的Run按钮，然后我们编写的程序就可以运行了。至于程序是如何编译和运行的，我们无须操心，因为IDE已经为我们封装好了：IDE集程序编辑器、工程管理器、编器汇编器、链接器、调试器、二进制工具、库、头文件于一身，留给用户的使用接口就是创建一个工程，编写代码，运行代码。这种一站式开发方式大大简化了软件的开发，程序员只需要关注自己要实现的业务逻辑和功能代码即可，至于底层是如何编译运行的，不用关心。

​		嵌入式开发和桌面开发不太一样：处理器平台和软件生态碎片化、多样化。为了提高性价比，不同的嵌入式系统往往采取更灵活的配置：不同的CPU平台、不同大小的存储、不同的启动方式，导致我们在编译程序时，有时候不仅要考虑一个嵌入式平台的内存、存储器的地址空间，还要考虑将我们的程序代码“烧”写到什么地方、加载到内存什么地方、如何执行。这就要求嵌入式工程师必须了解在程序运行的背后，它们是如何编译、链接和运行的。有了这些理论支撑，我们才可能灵活地根据硬件平台的差异去完成软件层面的编译优化和配置。

### 1.1 从源程序到二进制文件

​		程序的编译过程，其实就是将我们编写的C源程序翻译成CPU能够识别和运行的二进制机器指令的过程。关于C程序我们已经很熟悉了：一个C程序主要由一行行C语言语句组成，不同的语句构成一个个代码块或函数，每个语句由C语言的关键字、运算符、预处理命令、用户定义的变量名、函数名等很多token构成。一个C语言项目通
常由多个文件组成，生成的二进制可执行文件默认是a.out。

​		readelf-h命令主要用来获取可执行文件的头部信息，主要包括可执行文件运行的平台、软件版本、程序入口地址，以及program headers、section header等信息。通过文件的头部信息，我们可以知道在a.out可执行文件里一共有多少个section headers。它主要用来描述可执行文件的section信息，一个可执行文件通常由不同的段（section）构成：代码段、数据段、BSS段、只读数据段等。每个section用一个section header来描述，包括段名、段的类型、段的起始地址、段的偏移和段的大小等。一个可执行文件中的每一个section都有一个section header，将这些section headers集中放到一起，就是section header table，翻译成中文就是节头表。我们可以使用readelf-S命令来查看一个可执行文件的节头表。

在一个可执行文件中，我们比较熟悉的section有.text、.data、.bss，就是我们常说的代码段、数据段、BSS段。C程序中定义的函数、变量、未初始化的全局变量经过编译后会放置在不同的段中：函数翻译成二进制指令放在代码段中，初始化的全局变量和静态局部变量放在数据段中。**BSS段比较特殊，一般来讲，未初始化的全局变量和静态变量会放置在BSS段中，但是因为它们未初始化，默认值全部是0，其实没有必要再单独开辟空间存储，为了节省存储空间，所以在可执行文件中BSS段是不占用空间的。但是BSS段的大小、起始地址和各个变量的地址信息会分别保存在节头表sectionheader table和符号表.symtab里，当程序运行时，加载器会根据这些信息在内存中紧挨
着数据段的后面为BSS段开辟一片存储空间，为各个变量分配存储单元。**

​		**从C程序到可执行文件，整个编译过程并不是一气呵成、一步完成的，而是环环相扣、多步执行的**。如图4-3所示，程序的整个编译流程主要分为以下几个阶段：预处理、编译、汇编、链接。每个阶段需要调用不同的工具去完成，上一阶段的输出作为下一阶段的输入，步步推进。

![](https://raw.githubusercontent.com/bigshcool/myPic/main/202207271106673.png)

​		在一个多文件的C项目中，编译器是以C源文件为单位进行编译的。在编译的不同阶段，编译程序（如gcc、arm-linux-gcc）会调用不同的工具来完成不同阶段的任务。在编译器安装路径的bin目录下，你会看到各种各样的编译工具，gcc在程序编译过程中会分别调用它们，常见的工具有预处理器、编译器、汇编器、链接器。

- 预处理器：将源文件main.c经过预处理变为main.i。

- 编译器：将预处理后的main.i编译为汇编文件main.s。

- 汇编器：将汇编文件main.s编译为目标文件main.o。

- 链接器：将各个目标文件main.o、sub.o链接成可执行文件a.out。

  最后生成的可执行文件a.out其实也是目标文件（object file），唯一不同的是，a.out是一种可执行的目标文件。目标文件一般可以分为3种。

- 可重定位的目标文件（relocatable files）。

-  可执行的目标文件（executable files）。

- 可被共享的目标文件（shared object files）。

### 1.2 预处理过程

​		为了方便编程，编译器一般为开发人员提供一些预处理命令，使用＃标识。我们常见的预处理命令如下。

- 头文件包含：#include
- 定义一个宏：#define
- 条件编译:#if,#else,#endif
- 编译控制:#pragma

通过头文件包含可以实现模块化编程；使用宏可以定义一个常量，提高程序的可读性；通过条件编译可以让代码兼容不同的处理器架构和平台，以最大限度地复用公用代码。通过＃pragma预处理命令可以设定编译器的状态，指示编译器完成一些特定的动作。

- #pragma pack([n])：指示结构体和联合成员的对齐方式。
- #pragma message("string")：在编译信息输出窗口打印自己的文本信息。
- #pragma warning:有选择地改变编译器的警告信息行为
- #pragma once:在头文件中添加这条命令，可以防止头文件多次编译。

​        预处理过程，其实就是在编译源程序之前，先处理源文件中的各种预处理命令。编译器是不认识预处理指令的，在编译之前不先把这些预处理命令处理掉，编译器就会报错。预处理主要包括以下操作

- 头文件展开：将#include包含的头文件内容展开到当前位置。
- 宏展开：展开所有的宏定义，并删除#define
- 条件编译：根据宏定义条件，选择要参与编译的分支代码，其余的分支丢弃。
- 删除注释
- 添加行号和文件名标识：编译过程中根据需要可以显示这些信息。
- 保留#pragma命令：该命令会在程序编译时指令编译器执行一些特定行为。

### 1.3 程序的编译

​		经过预处理后的源文件，退去一切包装，注释被删除，各种预处理命令也基本上被处理掉，剩下的就是原汁原味的C代码了。接下来的第二步，就开始进入编译阶段。编译阶段主要分两步：

- 第一步，编译器调用一系列解析工具，去分析这些C代码，将C源文件编译为汇编文件
- 第二步，通过汇编器将汇编文件汇编成可重定位的目标文件

​        从C文件到汇编文件，其实就是从高级语言到低级语言的转换。通过前面的学习我们知道，一个汇编文件是以段为单位来组织程序的：代码段、数据段、BSS段等，各个段之间相互独立。

​		汇编程序的组织结构和二进制目标文件已经很接近了。没错，两者本质上其实就是等价的，汇编指令就是二进制指令的助记符，唯一的差异就是汇编语言的程序结构需要使用各种伪操作来组织。汇编文件经过汇编器汇编后，处理掉各种伪操作命令，就是二进制目标文件了。总体而言，编译过程可以分下以下六步。

- 词法分析

  ​		词法分析是编译过程的第一步，主要用来解析C程序语句。词法分析一般会通过词法扫描器从左到右，一个字符一个字符地读入源程序，通过有限状态机解析并识别这些字符流，将源程序分解为一系列不能再分解的记号单元——token。

  ​		token是字符流解析过程中有意义的最小记号单元，常见的token如下。

  - C语言的各种关键字：int、float、for、while、break等。
  - 用户定义的各种标识符：函数名、变量名、标号等。
  - 字面量：数字、字符串等。
  - 运算符：C语言标准定义的40多个运算符。
  - 分隔符：程序结束符分号、for循环中的逗号等。

- 语法分析

  ​		词法分析结束后，接着进行语法分析。语法分析主要是对前一阶段产生的token序列进行解析，看是否能构建成一个语法上正确的语法短语（程序、语句、表达式等）。语法短语用语法树表示，是一种树型结构，不再是线性序列。

  ​		语法分析工具在对token序列分析过程中，如果发现不能构建语法上正确的语句或
  表达式，就会报语法错误：syntax error。

- 语义分析

  ​		语法分析仅仅对程序做语法检查，对程序、语句的真正意义并不了解，而语义分析主要对语
  法分析输出的各种表达式、语句进行检查，看看有没有错误。

  ```c
  \\ 语法分析
  i = 10; \\正确
  
  \\ 语义分析
  i = 10; \\错误，因为结合上下文没有进行变量声明
  ```

  ​		如果你传递给函数的实参与函数声明的形参类型不匹配，或者你使用了一个未声明的变量，或者除数为零了，break在循环语句或switch语句之外出现了，或者在循环语句之外发现了continue语句，一般都会报语义上的错误或警告。

- 中间代码和目标代码生成

  ​		生成中间代码。在语法分析阶段输出的表达式或程序语句，还是以语法树的形式存储，我们需要将其转换为中间代码。中间代码是编译过程中的一种临时代码，常见的有三地址码、P-代码等。

  ​		中间代码和语法树相比，有很多优点：**中间代码是一维线性序列结构，类似伪代码，编译器很容易将中间代码翻译成目标代码。如上面的表达式语句**。

  ​        **中间码一般和平台是无关的**，如果你想将C程序编译为X86平台下的可执行文件，那么最后一步就是根据X86指令集，将中间代码翻译为X86汇编程序；如果你想编译成在ARM平台上运行的可执行文件，那么就要参考ARM指令集，根据ATPCS规则分配寄存器，将中间代码翻译成ARM汇编程序。

- 汇编代码生成

  ​		汇编过程是使用汇编器将前一阶段生成的汇编文件翻译成目标文件。汇编器的主要工作就是参考ISA指令集，将汇编代码翻译成对应的二进制指令，同时生成一些必要的信息，以section的形式组装到目标文件中，后面的链接过程会用到这些信息。

  ​       main.c，经过编译阶段后，会生成对应的main.o目标文件。main.o是不可执行的，属于可重定位的目标文件，它们要经过链接器重定位、链接之后，才能组装成一个可执行的目标文件a.out。

  ​		通过编译生成的可重定位目标文件，都是以零地址为链接起始地址进行链接的。**也就是说，编译器在将源文件翻译成可重定位目标文件的过程中，将不同的函数编译成二进制指令后，是从零地址开始依次将每一个函数的指令序列存放到代码段中，每个函数的入口地址也就从零地址开始依次往后偏移。我们使用readelf命令分析main.o这个目标文件。**

  ```sh
  readelf -S main.o
  ```

  ​		通过打印以零地址为基址进行代码段的组装。在每个可重定位目标文件中，函数或变量的地址其实就是它们在文件中相对于零地址的偏移。在每个可重定位目标文件中，函数或变量的地址其实就是它们在文件中相对于零地址的偏移。每个目标文件都是这样。

  ​		**那么问题出来，每个可重定位的目标文件的地址都是0开始的，在文件链接的过程汇总，连接器在将各个目标文件组装在一块时，各个目标文件的起始地址就发生了改变，那么这个目标文件内的函数或变量地址也要随之更新，否则就无法通过函数名去引用函数，无法通过变量名去引用变量。**

  ​		很简单，链接器将各个目标文件组装在一起后，我们需要重新修改各个目标文件中的变量或函数的地址，这个过程一般称为重定位。一个项目中有那么多文件，编译生成了那么多目标文件，链接器如何知道哪些函数或变量需要重定位呢？**很简单，我们把需要重定位的符号收集起来，生成一个重定位表**，以section的形式保存到每个可重定位目标文件中就可以了。

## 1.4 链接过程

​		在一个C项目的编译中，编译器以C源文件为单位，将一个个C文件翻译成对应的目标文件。生成的每一个目标文件都是由代码段、数据段、BSS段、符号表等section组成的。这些section从目标文件的零偏移地址开始按照顺序依次排放，每个段中的符号相对于零地址的偏移，其实就是每个符号的地址，**这样程序中定义的变量、函数名等，都有了一个暂时的地址。**

​		**在链接的过程中这些暂时的地址会被重新拆分，每个section的起始参考地址都会发生变化，导致session中定义的函数、全局变量也要随之发生变化，需要重新修订即重定位**，这些函数、全局变量等符号会同时被编译器收集起来放置在目标文件中。这些目标文件是不可执行的，他们需要连接器链接、重定位才能够运行。**链接过程:分段组装、符号决议和重定位**

- 分段组装

  ​		链接过程的第一步，就是将各个目标文件分段组装。链接器将编译器生成的各个可重定位目标文件重新分解组装：将各个目标文件的代码段放在一起，作为最终生成的可执行文件的代码段；将各个目标文件的数据段放在一起，作为可执行文件的数据段。其他section也会按照同样的方法进行组装。

  ​        除了代码段、数据段的分解组装需要关注，还有一个重要的section需要我们了解一下：符号表。**链接器会在可执行文件中创建一个全局的符号表**，收集各个目标文件符号表中的符号，然后将其统一放到全局符号表中。通过这步操作，一个可执行文件中的所有符号都有了自己的地址，并保存在全局符号表中，但此时全局符号表中的地址还都是原来在各个目标文件中的地址，即相对于零地址的偏移。

  ​        在链接过程中，不同的代码段如何组装？这也是很讲究的。链接生成的可执行文件最终是要被加载到内存中执行的，那么要加载到内存中的什么地方呢。**一般来讲，程序在链接程序时需要指定一个链接起始地址，链接开始地址一般也就是程序要加载到内存中的地址**。在链接过程中，各个段在可执行文件中的先后组装顺序也是一个需要考虑的问题，一个可执行程序肯定会有入口地址的，一般先执行的代码要放到前面。那么如何指定程序的链接地址和各个段的组装顺序呢？很简单，通过链接脚本就可以了。链接脚本本质上是一个脚本文件。在这个脚本文件里，不仅规定了各个段的组装顺序、起始地址、位置对齐等信息，同时对输出的可执行文件格式、运行平台、入口地址等信息做了详细的描述。链接器就是根据链接脚本定义的规则来组装可执行文件的，并最终将这些信息以section的形式保存到可执行文件的ELF Header中。

  ​		假如在一个嵌入式系统中，内存RAM的起始地址是0x60000000，我们在链接程序时，就可以在链接脚本中指定内存中的一个合法地址作为链接起始地址。程序运行时，加载器首先会解析可执行文件中的ELF Header头部信息，验证程序的运行平台和加载地址信息，然后将可执行文件加载到内存中对应的地址，程序就可以正常运行了。

  ​		在嵌入式裸机环境下编译程序，尤其是编译ARM底层代码，很多时候我们要根据开发版的不同硬件配置、内存大小和地址，灵活指定链接地址，或者显示指定链接脚本，有时候甚至自己编写链接脚本。

  ​		不同的编译器、不同的操作系统，链接脚本的文件名后缀一般也不一样。GCC编译器的默认链接脚本在/usr/lib/scripts目录下，而C-Free集成开发环境的默认链接脚本则在安装路径下的mingw/mingw32/lib/ldscripts下。
  ​        不同的编译器默认的链接地址也是不一样的，如笔者在Ubuntu 16.04环境下安装的32位GCC编译器，默认链接起始地址为0x08048000，32位ARM交叉编译器的默认链接起始地址0x10000。在一个由带有MMU的CPU搭建的嵌入式系统中，程序的链接起始地址往往都是一个虚拟地址，程序运行过程中还需要地址转换，通过MMU将虚拟地址转换为物理地址，然后才能访问内存，这部分内容属于CPU硬件底层要关心的内容，和编译原理是不冲突的。

- 符号决议

  ​		一个公司的项目通常由多人组成的软件团队共同开发。一个项目一般由产品经理定义功能需求，由架构师进行系统分析和模块划分，然后将各个模块的具体实现分配给不同的人员。开发人员在实现各自模块的编程中，**可能会产生一个问题：位于不同模块或不同文件中的全局变量、函数可能存在重名冲突。**

  ​		链接器早就料到会有这种情况，它有专门的符号决议规则来解决这种符号冲突。

  ​		编译器为了解决这种符号冲突，引入了强符号和弱符号的概念：函数名、初始化的全局变量是强符号，而未初始化的全局变量则是弱符号。有了强符号和弱符号的概念后，再理解上面的三句话就比较清晰了：在一个多文件的工程中，强符号不允许多次定义，否则就会发生重定义错误。强符号和弱符号可以在一个项目中共存，**当强弱符号共存时，强符号会覆盖掉弱符号，链接器会选择强符号作为可执行文件中的最终符号。**

  ​		链接器也允许一个项目中出现多个弱符号共存。在程序编译期间，编译器在分析每个文件中未初始化的全局变量时，并不知道该符号在链接阶段是被采用还是被丢弃，因此在程序编译期间，未初始化的全局变量并没有被直接放置在BSS段中，而是将这些弱符号放到一个叫作COMMON的临时块中，在符号表中使用一个未定义的COMMON来标记，在目标文件中也没有给它们分配存储空间。

  ​	 	**在链接期间，链接器会比较多个文件中的弱符号，选择占用空间最大的那一个，作为可执行文件中的最终符号，此时弱符号的大小已经确定，并被直接放到了可执行文件的BSS段中。**

  ​		**正常情况下，初始化的全局变量、函数名默认都是强符号，未初始化的全局变量默认是弱符号。如果在项目中有特殊需求，我们也可以将一些强符号显式转化为弱符号。**

  ​		和强符号、弱符号对应的，还有强引用、弱引用的概念。在一个程序中，我们可以定义多个函数和变量，变量名和函数名都是符号，这些符号的本质，或者说这些符号值，其实就是地址。在另一个文件中，我们可以通过函数名去调用该函数，通过变量名去访问该变量。我们通过符号去调用一个函数或访问一个变量，通常称之为引用（reference），**强符号对应强引用，弱符号对应弱引用**

  ​		利用链接器对弱引用的处理规则:**我们在引用一个符号之前可以先判断该符号是否存在（定义）**。这样做的好处是：当我们引用一个未定义符号时，在链接阶段不会报错，在运行阶段通过判断运行，也可以避免运行错误。举个例子，如果我们想实现一个视频解码模块，并最终封装成库的形式提供给应用程序开发者使用。在模块实现的过程中，我们可以将提供给用户的一系列API函数声明为弱符号，这样做有两个好处：一是当我们对库中的某些API函数的实现不是很满意，或者这些API存在bug，我们有更好的实现时，可以自定义与库函数同名的函数，直接调用它们而不会发生冲突。二是在库的实现过程中，我们可以将某些扩展功能模块中还未完成的一些API定义为弱引用。应用程序在调用这些API之前，要先判断该函数是否实现，然后才调用运行。这样做的好处就是未来发布新版本库时，无论这些接口是否已经实现，或者已经删除，都不会影响应用程序的正常链接和运行。

- 重定位

  ​        经过符号决议，我们解决了链接过程中多文件符号冲突的问题。经过处理之后，可执行文件的符号表中的每个符号虽然都确定下来了，但是还存在一个问题：符号表中的每个符号值，也就是每个函数、全局变量的地址，还是原来各个目标文件中的值，还都是基于零地址的偏移。链接器将各个目标文件重新分解组装后，各个段的起始地址都发生了变化。
  ​		在可执行文件中，各个段的起始地址都发生了变化，那么各个段中的符号地址也要跟着发生变化。编译器生成的各个目标文件，以零地址为起始地址放置各个函数的指令代码，各个函数相对于零地址的偏移就是各个函数的入口地址。

  ​		程序经过重新分解组装后，无论是代码段，还是数据段，各个符号的真实地址都发生了变化。而此时可执行文件的全局符号表中，各个符号的值还是原来的地址，所以接下来还要修改全局符号表中这些符号的值，将它们的真实地址更新到符号表中。修改完毕后，当我们想通过符号引用去调用一个函数或访问一个变量时，就能找到它们在内存中的真实地址了。

  ​		在编译阶段，编译器在将各个C源文件生成目标文件的过程中，遇到未定义的符号一般不会报错，编译器会认为这些符号可能会在其他地方定义。在链接阶段，链接器在其他地方找不到该符号的定义，才会报链接错误。编译器在链接阶段会搜集这些未定义的符号，生成一个重定位表，用来告诉链接器，这些符号在文件中被引用，但是在本文件中没有找到定义，有可能在其他文件或库中定义，“我就先不报错了，你链接的时候找找看”。
  ​		无论是代码段，还是数据段，只要这个段中有需要重定位的符号，编译器都会生成一个重定位表与其对应：.rel.text或.rel.data。这些重定位表记录各个段中需要重定位的各种符号，并以section的形式保存在各个目标文件中。我们可以通过readelf或objdump命令来查看一个目标文件中的重定位表信息。

### 1.5 程序的安装

​		以PC为例，如果你想在计算机上安装《荒野行动》游戏。首先你要从官方网站上下载这个游戏的安装包，接着把它安装到你的D盘上。安装成功后，在桌面上会留下一个快捷方式，双击快捷方式，程序开始运行，然后就可以愉快地到大城“刚枪”，到郊区打野了。软件安装的过程其实就是将一个可执行文件安装到ROM的过程。你下载的软件安装包里包含了可以在计算机上运行的可执行文件，游戏开发者为了方便用户使用，将可执行文件、程序运行时需要的动态共享库、安装使用文档等打包压缩，生成可运行的自解压安装包格式。使用安装包安装软件就是将包中的可执行文件解压出来，然后将可执行文件和动态共享库复制到指定的安装目录，并把这些安装信息告诉操作系统。当用户要运行这个软件时，操作系统就会从安装目录找到这个可执行文件，把它加载到内存执行。无论是在Linux环境还是在Windows环境，基本上都是遵循这个套路，只不过实现的方式不同而已。
​		**在Linux环境下，我们一般将可执行文件直接复制到系统的官方路径/bin、/sbin、/usr/bin下，程序运行时直接从这些系统默认的路径下去查找可执行文件，将其加载到内存运行。**

### 1.6 程序的运行

​		程序的运行分两种情况：**一种是在有操作系统的环境下执行一个应用程序；另一种是在无操作系统的环境下执行一个裸机程序**。在不同的环境下执行程序，文件的格式一般也会不一样，如在Linux环境下，可执行文件是ELF格式，而在裸机环境下执行的程序一般是BIN/HEX格式。BIN/HEX文件是纯指令文件，没有其他杂七杂八的辅助信息，而ELF文件除了基本的代码段、数据段，还有文件头、符号表、program headertable等用来辅助程序运行的信息。
​		**两种程序虽然运行环境不同，文件格式也有所差异，但原理是相通的：都要将指令加载到内存中的指定位置。而这个指定位置往往又与可执行文件链接时的链接地址有关。**

- 操作系统环境下的系统运行

  ​		一个装有操作系统的计算机系统，当执行一个应用程序时，首先会运行一个叫作加载器的程序。加载器会根据软件的安装路径信息，将可执行文件从ROM中加载到内存，然后进行一些与初始化、动态库重定位相关的操作，最后才跳转到程序的入口运行。**在不同的操作系统下，可以由不同的程序充当“加载器”的角色，如在Linux命令行模式下运行一个应用程序，类似sh、bash这样的Shell终端程序就充当加载器的角色：
  它们会把程序加载到内存，封装成进程，参与操作系统的调度和运行。**
  ​        一个可执行文件由不同的section组成，分为代码段、数据段、BSS段等。加载器在加载程序运行时，会将这些代码段、数据段分别加载到内存中的不同位置。可执行文件的文件头提供了文件类型、运行平台、程序的入口地址等基本信息，加载器在加载程序之前会首先根据文件头的信息做一些判断，如果发现程序的运行平台和当前的环境不符，则会报出错处理。

  ​		**在Linux环境下运行的程序一般都会被封装成进程，参与操作系统的统一调度和运行。在Shell环境下运行一个程序，Shell终端程序一般会先fork一个子进程，创建一个独立的虚拟进程地址空间，接着调用execve函数将要运行的程序加载到进程空间：通过可执行文件的文件头，找到程序的入口地址，建立进程虚拟地址空间与可执行文件的映射关系，将PC指针设置为可执行文件的入口地址，即可启动运行。**

  ​		在一个嵌入式Linux系统中，Linux内核镜像的运行其实就是裸机环境下的程序运行。Linux内核镜像一般会借助U-boot这个加载工具将其从Flash存储分区加载到内存中运行，U-boot在Linux启动过程中扮演了“加载器”的角色。

  - 在一台计算机上通常会运行多个进程，而每个进程的指令代码在编译时都是采用同一个链
    接地址的，在运行时它们会被加载到内存中的同一个地址吗？会不会产生地址冲突？

    程序链接时的链接地址其实都是虚拟地址。如图4-23所示，程序运行时，虽然每个进程的地址空间都是一样的，但是每个进程都有自己的页表，页表里的每一个条目叫页表项，页表项里存储的是虚拟地址和物理地址之间的映射关系，相同的虚拟地址经过MMU硬件转换后，会分别映射到物理内存的不同区域，彼此相互隔离和独立，一点也不会起冲突。

- 裸机上的程序运行

  ​		在操作系统环境下，我们可以通过加载器将程序的指令加载到内存中，然后CPU到内存中取指运行。在一个裸机平台下，系统上电后，没有程序运行的环境，我们需要借助第三方工具将程序加载到内存，然后才能正常运行。
  ​        很多集成开发环境如ADS1.2、Keil、RVDS等IDE，不仅提供了程序编辑、编译的功能，同时支持程序的运行、调试、烧写。以ADS1.2集成开发环境为例，如图4-25所示，它可以通过JTAG接口和开发板通信，将我们在PC上编译好的BIN/HEX格式的ARM可执行文件下载到开发板的内存中运行。

  ​		在一个嵌入式Linux系统中，Linux内核镜像的运行其实就是裸机环境下的程序运行。Linux内核镜像一般会借助U-boot这个加载工具将其从Flash存储分区加载到内存中运行，U-boot在Linux启动过程中扮演了“加载器”的角色。当然U-boot的功能绝不仅限于此，现在的U-boot功能已经很强大了，实现了各种各样的功能，这里不再赘述。

- 程序员入口main()函数分析

  ​		符号main是一个约定符号，它用来告诉编译器在一个项目中哪里是
  程序的入口点。程序员在开发一个项目时，也会遵守这个约定，使用main()函数作为项目的入口函数。

  ​		马未动，粮草先行。其实在main()函数运行之前，已经有“先头部队”代码提前运行了：**它们主要完成运行main()函数之前的一些初始化工作**，如初始化堆栈指针等。栈是C语言运行的必备环境，C语言函数调用过程中的参数传递、函数内部的局部变量都是保存在栈中的（详情请看第5章），没有栈C语言就无法运行，因此在运行main()函数之前必须先运行一段汇编代码来初始化堆栈环境。设置好堆栈指针后，这部分代码还要继续初始化一些环境，如初始化data段的内容，初始化static静态变量和global全局变量，并给BSS段的变量赋初值：未初始化的全局变量中，int类型的全部初始化为0，布尔型的变量初始化为FALSE，指针型的变量初始化为NULL。完成初始化环境
  后，这部分代码还会将用户传入的参数传递给main，最后才跳入main()函数运行。

  ​		**这部分初始化代码是在程序编译阶段，由编译器自动添加到可执行文件中的**。这部分代码属于C运行库（C Running Time，CRT）中的代码，编译器厂商在开发编译器时，除了实现C语言标准中规定的printf、fopen、fread等标准函数，还会实现这部分初始化代码，完成进入main()函数之前的一系列初始化操作。

  - C语言运行的基本堆栈环境，进程环境
  - 动态库的加载、释放、初始化、清理等工作
  - 向main()函数传递参数argc、argv,调用main()函数执行
  - 在main()函数退出后，条用exit()函数，结束进程的运行

- BBS段的小秘密

  ​		对于未初始化的全局变量和静态局部变量，编译器将其放置在BSS段中。BSS段是不占用可执行文件存储空间的，早期的计算机存储资源昂贵而且比较紧张，设置BSS段的目的主要就是减少可执行文件的体积，节省磁盘空间。

  ​		虽然BBS段在可执行文件中不占用存储空间，但是当程序加载到内存运行时，加载器会在内存中给BSS段开辟一段存储空间。在section header table中会记录BSS段的大小，在符号表中会记录每个变量的地址和大小。

  ​		加载器会根据这些信息，在数据段的后面分配指定大小的内存空间并清零，根据符号表中各个变量的地址，在这片内存中给各个未初始化的全局变量、静态变量分配存储空间。到了这一步，一个程序被加载到内存后，它在内存中的分布如图所示。

![](https://raw.githubusercontent.com/bigshcool/myPic/main/202208031528876.png)

- 链接静态库

  ​		为了完成特定功能，除了自定义函数，我们还可以使用别人已经封装好的函数库，如C标准库、音视频编解码库等。库函数的使用避免了“造轮子”的重复工作，提高了代码复用率，大大减轻了软件开发的工作量。

  ​		库分为静态库和动态库两种。如果我们在项目中引用了库函数，则在编译时，链接器会将我们引用的函数代码或变量，链接到可执行文件里，和可执行程序组装在一起，这种库被称为静态库，即在编译阶段链接的库。动态库在编译阶段不参与链接，不会和可执行文件组装在一起，而是在程序运行时才被加载到内存参与链接，因此又叫作动态链接库。
  ​		**静态库的本质其实就是可重定位目标文件的归档文件**。静态库的制作和使用都很简单，使用AR命令就可以将多个目标文件打包为一个静态库。

  ```c
  //test.c
  int add(int a,int b){
  	return a + b;
  }
  
  int sub(int a,int b){
  	return a - b;
  }
  
  // main.c
  #include<stdio.h>
  
  int add(int,int)
  int main(void){
      int sum = 0;
      sum = add(1,2)
      printf("sum = %d\n", sum);
      return 0;
  }
  ```

  ![](https://raw.githubusercontent.com/bigshcool/myPic/main/202208031548664.png)

  ​        首先我们将源文件test.c编译生成对应的目标文件test.o，然后使用ar命令将多个目标文件打包成libtest.a，最后在编译main.c时，通过参数指定要链接的静态库及其所在路径就可以了。编译参数大写的L表示要链接的库的路径，小写的l表示要链接的库名字。链接时库的名字要去掉前后缀，如libtest.a，链接时要指定的库名字为test。

  ​        编译器是以源文件为单位编译程序的，链接器在链接过程中逐个对目标文件进行分解组装，这样很容易产生一个问题：如果在一个源文件中我们定义了100个函数，而只使用了其中的1个，那么链接器在链接时也会把这100个函数的代码指令全部组装到可执行文件中，这会让最终生成的可执行文件体积大大增加。使用readelf命令查看a.out你会发现，虽然我们在main()函数中只调用了add()函数，但是在a.out文件中除了add()函数，sub()等函数也都链接了进来，这可如何是好呢？

  ​		解决这个问题其实很简单：我们在封装函数库时，将每个函数都单独使用一个源文件实现，然后将多个目标文件打包即可。

  ```c
  // add.c
  int add(int a,int b){
  	return a + b;
  }
  
  //sub.c
  int sub(int a,int  b){
  	return a - b
  }
  
  //mian.c
  #include<stdio.h>
  int add(int,int)
  
  int main(void){
  	int sum;
  	sum = add(1,2);
  	printf("sum = %d\n", sum);
  	return 0;
  }
  ```

  ​        我们将上面的源文件分别编译，打包成静态库，再去调用库中的add函数，你们发现，sub()等函数就不回连接到可执行文件中去。

  ​        C标准包库其实就是这么干的：在glibc源码中，你会看到，每一个库函数都是单独使用一个同名的源文件实现的。printf()函数单独定义在printf.c文件中，scanf()函数单独定义在scanf.c文件中，如果你调用了一个printf()函数，则链接器只是将printf()函数的目标文件链接到你的可执行文件中。通过这种打包形式，可执行文件的体积被大大减少了。

  ​		静态链接还会产生另外一个问题。如C标准库里的printf()函数，可能多个程序都调用了它，链接器在链接时就要将printf的指令添加到多个可执行文件中。在一个多任务环境中，当多个进程并发运行时，你会发现内存中有大量重复的printf指令代码，很浪费内存资源。那么有没有解决的办法呢？肯定是有的，动态链接这时候就开始低调登场了。

  ​		为了解决这个问题，动态链接对静态链接做了一些优化：对一些公用的代码，如库，在链接期间暂不链接，而是推迟到程序运行时再进行链接。这些在程序运行时才参与链接的库被称为动态链接库。程序运行时，除了可执行文件，这些动态链接库也要跟着一起加载到内存，参与链接和重定位过程，否则程序可能就会报未定义错误，无法运行。

- 动态链接

  ​        生成的可执行文件体积较大，当多个程序引用相同的公共代码时，这些公共代码会多次加载到内存，浪费内存资源。尤其对于一些内存配置较低的嵌入式系统，当过多的进程并发运行时，系统就可能因为内存爆满而无法流畅运行。

  ​		为了解决这个问题，动态链接对静态链接做了一些优化：**对一些公用的代码，如库，在链接期间暂不链接，而是推迟到程序运行时再进行链接。这些在程序运行时才参与链接的库被称为动态链接库。程序运行时，除了可执行文件，这些动态链接库也要跟着一起加载到内存，参与链接和重定位过程，否则程序可能就会报未定义错误，无法运行。**

  ​		在Linux环境下，动态库的文件变成了以.so为后缀。一个软件采用动态链接，版本升级时主程序的业务逻辑或框架不需要改变，只需要更新对应的.dll或.so文件就可以了，简单方便，也避免了用户重复安装卸载软件。以上面的main.c、add.c、sub.c程序为例，我们可以将add.c、sub.c封装成动态库libtest.so，然后在程序运行时动态加载到内存。

  ![image-20220803163837824](C:\Users\86133\AppData\Roaming\Typora\typora-user-images\image-20220803163837824.png)

  ​		在上面的程序中，可执行文件a.out是采用动态链接生成的，所以在运行a.out之前，libtest.so这个动态链接库要放到/lib、/usr/lib等系统默认的库路径下，否则a.out就会动态链接失败，无法正常运行。

  ​        **在Linux环境下，当我们运行一个程序时，操作系统首先会给程序fork一个子进程，接着动态链接器被加载到内存，操作系统将控制权交给动态链接器，让动态链接器完成动态库的加载和重定位操作，最后跳转到要运行的程序。动态链接器在C标准库中实现，是glibc的一部分，主要完成程序运行前的动态链接工作，在可执行文件的.interp段中存放的有动态链接器的加载路径，我们可以通过objdump命令查看。**

  ​		**动态链接器本身也是一个动态库，即/lib/ld-linux.so文件。动态链接器被加载到内存后，会首先给自己重定位，然后才能运行。像这种自己给自己重定位然后自动运行的行为，我们一般称为自举**。在嵌入式系统中，大家比较熟悉的U-boot也有自举功能，它在系统上电启动后会完成代码的自我复制和重定位操作，然后加载Linux内核镜像运行。

  ​        动态链接器解析可执行文件中未确定的符号及需要链接的动态库信息，将对应的动态库加载到内存，并进行重定位操作。这个过程其实和静态链接的重定位过程一样，只不过推迟到了运行阶段而已。重定位结束后，程序中要引用的所有符号都有了地址和定义，动态链接器将控制权交给要执行的程序，跳转到该程序运行。

  ![](https://raw.githubusercontent.com/bigshcool/myPic/main/202208031708914.png)

  - 动态链接地址加载

    ​        动态链接需要考虑的一个重要问题是加载地址。一个静态链接的可执行文件在运行时，一般加载地址等于链接地址，而且这个地址是固定的。可执行文件是操作系统帮我们创建一个子进程后，第一个被加载到进程空间的文件，此时进程的地址空间一马平川，还未被占用，所以不用考虑地址空间资源的问题。**动态链接库加载到内存中的地址则是随机的，因为每一个可执行文件的大小不同，加载到内存后剩余的地址空间也不尽相同，动态链接库的地址要根据进程地址空间的实际空闲情况随机分配**。在这种情况下，动态链接库该如何运行呢？

    ​		很容易想到的一个方法就是装载时重定位。在静态链接过程中，每个目标文件中的代码段都被分解组装，起始地址发生了变化，要进行重定位，然后程序才可以运行。类似静态链接的重定位，动态链接库被加载到内存后，目标文件的起始地址也发生了变化，需要重定位。一个可执行文件对动态链接库的符号引用，要等动态链接库加载到内存后地址才能确定，然后对可执行文件中的这些符号修改即可。以上面的例
    子为例，main()函数调用了add()函数，但add()函数的地址还不确定，等到libtest.so加载到内存后add()函数的地址才能确定下来。加载器通过动态链接、重定位操作，更新了符号表中add()函数的实际地址，并修正main()函数指令中引用add()函数的地址，然后程序才可以正常运行。

    ​        这种装载时重定位操作，虽然解决了可执行文件中对绝对地址的引用问题，但也带来了另外一个问题：对于每个进程，动态库被加载到了内存的不同地址，也只能被进程自身共享，无法在多个进程间共享，无法节省内存，违背了动态库的设计初衷。如果有一种好方法，将我们的动态库设计成无论放到哪里，都可以执行，而且可以被多个进程共享，那么这个问题就迎刃而解了。

  - 与地址无关的代码

    ​       如果想让我们的动态库放到内存的任何位置都可以运行，都可以被多个进程共享，一种比较好的方法是将我们的动态库设计成与地址无关的代码。其实现思路很简单：将指令中需要修改的部分（如对绝对地址符号的引用）分离出来，剩余的部分就和地址无关了，放到哪里都可以执行，而且可以被多个进程共享。需要被修改的指令（符号）和数据在每个进程中都有一个副本，互不影响各自的运行。
    ​       先把需要修改的部分放到一边，暂且不谈，我们先讨论动态库中与地址无关的代码部分。与地址无关的代码实现也很简单，编译代码时加上-fPIC参数即可。PIC是Position-Independent Code的简写，即与地址无关的代码。加上-fPIC参数生成的指令，实现了代码与地址无关，放到哪里都可以执行。

    ```shell
    arm-linux-gnueabi-gcc -fPIC -c main.c
    ```

    实现PIC需要底层相关的技术支撑，不同的平台有不同的实现方式。实现代码与地址无关，在模块内部，对函数和全局变量的引用要避免使用绝对地址，一般可以使用相对跳转代替。以ARM平台为例，可以采用相对寻址来实现。ARM有多种寻址方式，
    其中有一种叫相对寻址，以PC为基址，以当前指令和目标地址的差作为偏移量，两者相加的地址即操作数的有效地址。ARM汇编中的B、BL、ADR、ADRL等指令都是采用相对寻址实现的。
    
  - 全局偏移表

    ​		在动态库的设计中，对于模块内的符号相互引用，我们通过相对寻址很容易实现代码与地址无关。但是当动态库作为第三方模块被不同的应用程序引用时，库中的一些绝对地址符号（如函数名）将不可避免地被多次调用，需要重定位。动态库中的这些绝对地址符号，如何能做到同时被不同的应用程序引用呢？

    ​		解决这个问题的核心思想其实也很简单：每个应用程序将引用的动态库（绝对地址）符号收集起来，保存到一个表中，这个表用来记录各个引用符号的地址。当程序在运行过程中需要引用这些符号时，可以通过这个表查询各个符号的地址。这个表被称为全局偏移表（Global Offset Table，GOT）。

    ​        在一个可执行文件中，其引用的动态库中的绝对地址符号（如函数名）会被分离出来，单独保存到GOT表中，GOT表以section的形式保存在可执行文件中，这个表的地址在编译阶段就已经确定了。当程序运行需要引用动态库中的函数时，会将动态库加载到内存，根据动态库被加载到内存中的具体地址，更新GOT表中的各个符号（函数）的地址。等下次该符号被引用时，程序可以直接跳到GOT表查询该符号的地址，如果找到要调用的函数在内存中的实际地址，就可以直接跳过去执行了。因为GOT表在可执行文件中的位置是固定不变的，所以程序中访问GOT表的指令也是固定不变的，唯一需要变化的是：动态库加载到内存后，库中的各个函数的位置确定，在GOT表中实时更新各个符号在内存中的真实地址就可以了。

    ​        这样做的好处是：在内存中只需要加载一份动态库，当不同的程序运行时，只要修改各自的GOT表，它们引用的符号都可以指向同一份动态库，就可以达到不同程序共享同一个动态库的目标了。

  - 延迟绑定

    ​		动态链接通过使用"与地址无关"这一技术，加载到内存任意地址都可以运行。“与
    地址无关”这一技术在ARM平台可以使用相对寻址来实现。ARM相对寻址的本质其实
    就是寄存器间接寻址，只不过基址换成了PC而已，访问效率还是比较低的，包括程序
    运行之前的动态链接和重定位操作，也会对程序的及时响应和性能造成一定的影响。
    我们假设一个软件中有几百个地方使用了动态链接，如果把所有的动态库一次性全部
    加载到内存并一一对它们进行重定位，会耗费不少的时间。程序中存在大量的if-else分
    支，并不是所有的指令都能执行到，我们加载到内存的动态库可能根本就没有被调用
    到，这又会白白浪费内存空间。基于这个原因，可执行文件一般都采用延迟绑定：程
    序在运行时，并不急着把所有的动态库都加载到内存中并进行重定位。当动态库中的
    函数第一次被调用到时，才会把用到的动态库加载到内存中并进行重定位。这样做既
    节省了内存，又可以提高程序的运行速度，因此得到广泛应用。
    
  - 共享库

    ​		现在大多数软件都是采用动态链接的方式开发的，不仅可以节省内存空间，升级
    维护也比较方便。在发布软件包时，可执行文件及其依赖的动态链接共享库被一起打
    包发布，如果你依赖的是系统默认自带的共享库，如C标准库，则不需要跟软件一起
    打包。程序安装时，可执行文件会复制到Linux系统的默认路径下，如/bin、/sbin、/
    usr/bin、/usr/sbin、/usr/local/bin等，这些路径由环境变量PATH管理和维护。可执行文
    件依赖的共享库一般要放到库的默认路径下面，如/lib、/usr/lib等。当程序运行时，动
    态链接器首先被加载到内存运行，动态链接器会分析可执行文件，从可执行文件
    的.dynamic段中查询该程序运行需要依赖的动态共享库，然后到库的默认路径下查找
    这些共享库，加载到内存中并进行动态链接，链接成功后将CPU的控制权交给可执行
    程序，我们的程序就可以正常运行了。

    ​		动态链接器在查找共享库的过程中，除了到系统默认的路径（/lib、/usr/lib）下查
    找，也会到用户指定的一些路径下去查找，用户可以在/etc/ld.so.conf文件中添加自己
    的共享库路径。为减少每次查找文件的时间消耗，/etc/ld.so.conf修改后，我们也可以
    使用ldconfig命令生成一个缓存/etc/ld.so.chche以提高查找效率。每当我们新增、删除或
    修改共享库的路径时，使用ldconfig更新一下缓存就可以了。

    ​		系统中的所有程序在运行时，都会按照上面的这种方式查找共享库。有时候我们
    也可以使用LD_LIBRARY_PATH环境变量临时改变共享库的查找路径，而不会影响系
    统中的其他应用程序。我们可以将多个共享库的路径添加到这个环境变量中，各个路
    径用冒号隔开。

    ```
    export LD_LIBRARY_PATH = /home/wit/lib:/usr/test/lib
    ```

    ​		插件的本质其实就是共享动态库，只不过组装的形式比较复杂。有了前面的知识
    铺垫，我们再去理解插件的工作原理就很轻松了：主程序框架引用的外部模块符号，
    运行时以动态链接库的形式加载进来并进行重定位，就可以直接调用了。我们只需要
    将这些功能模块实现，做成支持动态加载的插件，就可以很方便地扩展程序的功能
    了。Linux提供了专门的系统调用接口，支持显式加载和引用动态链接库，常用的系统
    调用API如下。

    - 加载动态链接库

      ```c
      void *dlopen(const char *filename ,int flag);
      void *Handle = dlopen("./libtest.so", RTLD_LAZY)
      ```

      dlopen()函数返回的是一个void*类型的操作句柄，我们通过这个句柄就可以操作显式加载到内存中的动态库。函数的第一个参数就是要打开的动态链接库，第二个参数是打开标志位，经常使用的编辑为有如下几种。

      - RTLD_LAZY:解析动态库遇到未定义符号不退出，仍然继续使用。
      - RTLD_NOW:遇到未定义符号，立即退出。
      - RTLD_GLOBAL:允许退出符号，在后面其他动态库中可以引用。

    - 获取动态对象的地址

    ```c
    void *dlsym(void *handle, char *symbol);
    void (* funcp)(int ,int);
    funcp = (void(*)(int,int)) dlsym(Handle,"myfunc");
    ```

    dlsym()函数根据动态链接库句柄和要引用的符号，返回符号对应的地址。一般我们要先定义一个指向这种符号类型的指针，用来保存该符号对应的地址。通过指针，我们就可以引用动态库理的这个函数或者全局变量了。

    - 关闭动态链接库

    ```
    int dlclose(void *Handle);
    ```

    ​		该函数会将加载到内存中的共享库的引用计数减一，当引用技术为0的时候，该共享动态库就会从系统中被删除。

    - 动态库的错误函数

    ```
    const chat *dlerror (void);
    ```

    ​		当动态链接库操作函数失败时，dlerror将返回出错信息。若没有出错,则dlerror返回值为NULL。

    ```sh
    # -shared:表示生成共享库
    # -fPic:则表明使用地址无关代码
    gcc sub.c -shared -fPic -o libtest.so
    # 当dlopen、dlsym、dlclose、dlerror 显示加载动态库，需要设置链接选项 -ldl
    gcc maic.c -ldl
    ./a.out
    ```

    具体的main.c文件如下
    
    ```c
    #include<stdio.h>
    #include<stdlib.h>
    #include<dlfcn.h>
    
    typedef int (*cac_func)(int,int);
    
    int main(void){
            void *handle;
            cac_func fp = NULL;
    
            handle = dlopen("./libtest.so",RTLD_LAZY);
            if(!handle){
                    fprintf(stderr,"%s\n",dlerror());
                    exit(EXIT_FAILURE);
            }
            fp = dlsym(handle, "add");
            if(fp)
                    printf("add:%d\n", fp(8, 2));
            fp = (cac_func)dlsym(handle, "sub");
            if(fp)
                    printf("sub:%d\n", fp(8, 2));
     
            dlclose(handle);
            exit(EXIT_SUCCESS);
    }
    ```
    
    sub.c的文件如下
    
    ```c
    int add(int a,int b){
            return a + b;
    }
    
    int sub(int a,int b){
            return a - b;
    }
    ```
    
    - Linux内核模块运行
    
      ​		Linux内核实现了一个比较酷的功能:支持模块的动态加载和运行。如果你实现了
      一个内核模块并打算运行它，你并不需要重启系统，直接使用insmod命令加载即可，
      这个模块就像“补丁”一样打进了Linux操作系统，并可以正常运行。一个最简单的内核
      模块源码如下。
    
      **待补充**
    
    - Linux内核编译和启动分析
    
      **待补充**

## 2. 内存堆栈管理

​		我们在C程序中定义的函数、全局变量、静态变量经过编译链接后，分别以
section的形式存储在可执行文件的代码段、数据段和BSS段中。当程序运行时，可执
行文件首先被加载到内存中，各个section分别加载到内存中对应的代码段、数据段和
BSS段中。需要动态链接的动态库也被加载到内存中，完成代码的链接和重定位操
作，以保证程序的正常运行。一个可执行文件被加载到内存中运行时，它在内存空间
的分布如图。

![](https://raw.githubusercontent.com/bigshcool/myPic/main/202208161048240.png)

###  2.1程序运行的马甲：进程

​		在操作系统下运行一个程序，都会被封装成进程的形式，由操作系统管理、调度和运行。当我们在Shell交互环境下运行./hello时，bash会解析我们的命令和参数，调用fork创建一个子进程，接着调用exec()函数将hello可执行文件的代码段、数据段加载到内存，替换掉子进程的代码段和数据段。然后bash会解析我们在交互环境下输入的参数，将解析的参数列表argv传递给main，最后跳到main()函数执行。在Linux系统中，每个进程都使用一个task_struct结构体表示，各个task_struct构成一个链表，由操作系统的调度器管理和维护，每一个进程都会接受操作系统的任务调度，轮流占用CPU去运行。

![](https://raw.githubusercontent.com/bigshcool/myPic/main/202208161057698.png)	

​	程序是安装在磁盘上某个路径下的二进制文件，而进程则是一个程序运行的实例：操作系统会从磁盘上加载这个程序到内存，分配相应的资源、初始化相关的环境，然后调度运行。

​	**在一个进程的地址空间中，代码段、数据段、BSS段在程序加载运行后，地址就已经固定了，在整个程序运行期间不再发生变化，这部分内存一般也称为静态内存。而在程序中使用malloc申请的内存、函数调用过程中的栈在程序运行期间则是不断变化的，这部分内存一般也称为动态内存**。用户使用malloc申请的内存一般被称为堆内存（heap），函数调用过程中使用的内存一般被称为栈内存（stack)。

###	 2.1.1Linux环境下的内存管理

​		在Linux环境下运行的程序，在编译时链接的起始地址都是相同的，而且是一个虚拟地址。Linux操作系统需要CPU内存管理单元的支持才能运行，Linux内核通过页表和MMU硬件来管理内存，完成虚拟地址到物理地址的转换、内存读写权限管理等功能。可执行文件在运行时，加载器将可执行文件中的不同section加载到内存中读写权限不同的区域，如代码段、数据段、.bss段、.rodata段等。

​		计算机上运行的程序主要分为两种：操作系统和应用程序。**每一个应用程序进程都有4GB大小的虚拟地址空间。为了系统的安全稳定，0～4GB的虚拟地址空间一般分为两部分：用户空间和内核空间。0～3GB地址空间给应用程序使用，而操作系统一般运行在3～4GB内核空间**。通过内存权限管理，应用程序没有权限访问内核空间，只能通过中断或系统调用来访问内核空间，这在一定程度上保障了操作系统核心代码的稳定运行。

​		现在很多高端的SoC芯片，随着集成的IP模块越来越多，导致Linux内核镜像运行时需要的地址空间也越来越大。在很多处理器平台下，大家也经常看到如图5-3所示的划分：0～2GB的地址空间为用户空间，2～4GB的地址空间为内核空间。所有用户进程共享内核地址空间，但独享各自的用户地址空间。

​		在Linux环境下，虽然所有的程序编译时使用相同的链接地址，但在程序运行时，相同的虚拟地址会通过MMU转换，映射到不同的物理内存区域，各个可执行文件被加载到内存不同的物理页上。每个进程都有各自的页表，用来记录各自进程中虚拟地址到物理地址的映射关系。

![](https://raw.githubusercontent.com/bigshcool/myPic/main/202208161110701.png)

​		通过这种地址管理，每个进程都可以独享一份独立的、私有的3GB用户空间。编译器在编译程序时，不用考虑每个程序在实际物理内存中的地址分配问题。通过内存读写权限管理，可以保护每个进程的空间不被其他进程破坏，从而保障系统的安全运行。其实也可以完全不用考虑物理内存分配的问题，直接从每个进程的虚拟空间申请和释放，不用关心底层到底是如何映射到物理内存的，Linux的内存管理系统会自动帮我们完成这些转换，不会影响我们对编译原理和堆栈内存的分析。

​		堆内存一般在BSS段的后面，随着用户使用malloc申请的内存越来越多，堆空间不断往高地址增长。栈空间则紧挨着内核空间，ARM使用的是满递减堆栈，栈指针会从用户空间的高地址往低地址不断增长。在堆栈之间的一片茫茫空间中，还有一块区域叫作MMAP区域，我们上一章学习的动态共享库就是使用这片地址空间的。

![](https://raw.githubusercontent.com/bigshcool/myPic/main/202208161121134.png)

### 2.1.2 栈的管理

​		栈有两种基本操作：入栈（push）和出栈（pop）。入栈是把一个栈元素压入栈中，而出栈则是从栈中弹出一个栈元素。入栈和出栈都靠栈指（Stack Pointer，SP）来维护，SP会随着入栈和出栈在栈顶上下移动。如图5-7所示，根据栈指针SP指向栈顶元素的不同，栈可分为满栈和空栈；根据栈的生长方向不同，栈又分为递增栈和递减栈。

![](https://raw.githubusercontent.com/bigshcool/myPic/main/202209251020627.png)

​		栈是C语言运行的基础。**C语言函数中的局部变量、传递的实参、返回的结果、编译器生成的临时变量都是保存在栈中的，离开了栈，C语言就无法运行**。在很多嵌入式系统的启动代码中，你会看到：**系统一上电开始运行的都是汇编代码，在跳到第一个C语言函数运行之前，都要先初始化栈空间。**

- 栈的初始化

  ​		**栈的初始化其实就是栈指针SP的初始化**。在系统启动过程中，内存初始化后，将栈指针指向内存中的一段空间，就完成了栈的初始化，栈指针指向的这片内存空间被称为栈空间。不同的处理器一般都会使用专门的寄存器来保存栈的起始地址，X86处理器一般使用ESP（栈顶指针）和EBP（栈底指针）来管理堆栈，而ARM处理器则使用R13寄存器（SP）和R11寄存器（FP）来管理堆栈。

  ​		在栈的初始化过程中，栈在内存中的起始地址还是有点讲究的。ARM处理器使用的是满递减栈，在Linux环境下，栈的起始地址一般就是进程用户空间的最高地址，紧挨着内核空间，栈指针从高地址往低地址增长。为了防止黑客栈溢出攻击，新版本的Linux内核一般会将栈的起始地址设置成随机的，每次程序运行，栈的
  初始化起始地址都会基于用户空间的最高地址有一个随机的偏移，每次栈的起始地址都不一样。

  ![](https://raw.githubusercontent.com/bigshcool/myPic/main/202209251026870.png)

  ​		栈初始化后，栈指针就指向了这片栈空间的栈顶，当需要入栈、出栈操作时，栈指针SP就会随着栈顶的变化上下移动。在一个满递减栈中，栈指针SP总是指向栈顶元素。在栈的初始化过程中，除了指定栈的起始地址，我们还需要指定栈空间的大小。在Linux环境下，我们可以通过下面的命令来查看和设置栈的大小

  ```shell
  //查看栈的大小
  ulimit -s
  //设置栈的大小
  ulimit -s 8192
  ```

  ​		Linux默认给每一个用户进程栈分配8MB大小的空间。栈的容量如果设置得过大，
  则会增加内存开销和启动时间；如果设置得过小，则程序超出栈设置的内存空间又容
  易发生栈溢出（Stack Overflow），产生段错误。一个函数内定义的局部变量都是保存
  在栈空间的，我们据此可以编写一个让栈溢出的最简单程序。

  ```c
  // hello.c
  #include<stdio.h>
  
  int main(void){
  	char a[8*1024*1024];
  	int i;
  	printf("Hello world\n");
  	return 0;
  }
  ```

  ​		在设置栈大小时，我们要根据程序中的变量、数组对栈空间的实际需求，设置合
  理的栈大小。用户在编写程序时，为了防止栈溢出，可以参考下面的一些原则。

  - 尽量不要在函数内使用大数组，如果确实需要大块内存，则可以使用malloc申请
    动态内存。
  - 函数的嵌套层数不宜过深。
  - 递归的层数不宜太深。

- 函数调用

  ​		栈是C语言运行的基础，一个函数内定义的局部变量、传递的实参都是保存在栈
  中的。每一个函数都会有自己专门的栈空间来保存这些数据，每个函数的栈空间都被
  称为栈帧（Frame Pointer，FP）。每一个栈帧都使用两个寄存器FP和SP来维护，FP指
  向栈帧的底部，SP指向栈帧的顶部。

  ​		函数的栈帧除了保存局部变量和实参，还用来保存函数的上下文。如图所
  示，我们在main()函数中调用了f()函数，main()函数的栈帧基址FP、main()函数的返回
  地址LR，都需要保存在f()函数的栈帧中。当f()函数运行结束退出时就可以根据栈中保
  存的地址返回函数的上一级继续执行。