# 嵌入式编程自我修养的读书心得

## 1. 程序的编译、链接、安装和运行

​		在 Windows 下 开 发 一 个 C 程 序， 一 般 都 会 用 到 集 成 开 发 环 境 （Integrated Development Environment，IDE），如VC++6.0、C-Free、Visual Studio、Keil等。IDE 界面友好，使用方便，5分钟就可以快速上手：新建一个工程/源文件，编辑程序，点击界面上的Run按钮，然后我们编写的程序就可以运行了。至于程序是如何编译和运行的，我们无须操心，因为IDE已经为我们封装好了：IDE集程序编辑器、工程管理器、编器汇编器、链接器、调试器、二进制工具、库、头文件于一身，留给用户的使用接口就是创建一个工程，编写代码，运行代码。这种一站式开发方式大大简化了软件的开发，程序员只需要关注自己要实现的业务逻辑和功能代码即可，至于底层是如何编译运行的，不用关心。

​		嵌入式开发和桌面开发不太一样：处理器平台和软件生态碎片化、多样化。为了提高性价比，不同的嵌入式系统往往采取更灵活的配置：不同的CPU平台、不同大小的存储、不同的启动方式，导致我们在编译程序时，有时候不仅要考虑一个嵌入式平台的内存、存储器的地址空间，还要考虑将我们的程序代码“烧”写到什么地方、加载到内存什么地方、如何执行。这就要求嵌入式工程师必须了解在程序运行的背后，它们是如何编译、链接和运行的。有了这些理论支撑，我们才可能灵活地根据硬件平台的差异去完成软件层面的编译优化和配置。

### 1.1 从源程序到二进制文件

​		程序的编译过程，其实就是将我们编写的C源程序翻译成CPU能够识别和运行的二进制机器指令的过程。关于C程序我们已经很熟悉了：一个C程序主要由一行行C语言语句组成，不同的语句构成一个个代码块或函数，每个语句由C语言的关键字、运算符、预处理命令、用户定义的变量名、函数名等很多token构成。一个C语言项目通
常由多个文件组成，生成的二进制可执行文件默认是a.out。

​		readelf-h命令主要用来获取可执行文件的头部信息，主要包括可执行文件运行的平台、软件版本、程序入口地址，以及program headers、section header等信息。通过文件的头部信息，我们可以知道在a.out可执行文件里一共有多少个section headers。它主要用来描述可执行文件的section信息，一个可执行文件通常由不同的段（section）构成：代码段、数据段、BSS段、只读数据段等。每个section用一个section header来描述，包括段名、段的类型、段的起始地址、段的偏移和段的大小等。一个可执行文件中的每一个section都有一个section header，将这些section headers集中放到一起，就是section header table，翻译成中文就是节头表。我们可以使用readelf-S命令来查看一个可执行文件的节头表。

在一个可执行文件中，我们比较熟悉的section有.text、.data、.bss，就是我们常说的代码段、数据段、BSS段。C程序中定义的函数、变量、未初始化的全局变量经过编译后会放置在不同的段中：函数翻译成二进制指令放在代码段中，初始化的全局变量和静态局部变量放在数据段中。**BSS段比较特殊，一般来讲，未初始化的全局变量和静态变量会放置在BSS段中，但是因为它们未初始化，默认值全部是0，其实没有必要再单独开辟空间存储，为了节省存储空间，所以在可执行文件中BSS段是不占用空间的。但是BSS段的大小、起始地址和各个变量的地址信息会分别保存在节头表sectionheader table和符号表.symtab里，当程序运行时，加载器会根据这些信息在内存中紧挨
着数据段的后面为BSS段开辟一片存储空间，为各个变量分配存储单元。**

​		**从C程序到可执行文件，整个编译过程并不是一气呵成、一步完成的，而是环环相扣、多步执行的**。如图4-3所示，程序的整个编译流程主要分为以下几个阶段：预处理、编译、汇编、链接。每个阶段需要调用不同的工具去完成，上一阶段的输出作为下一阶段的输入，步步推进。

![](https://raw.githubusercontent.com/bigshcool/myPic/main/202207271106673.png)

​		在一个多文件的C项目中，编译器是以C源文件为单位进行编译的。在编译的不同阶段，编译程序（如gcc、arm-linux-gcc）会调用不同的工具来完成不同阶段的任务。在编译器安装路径的bin目录下，你会看到各种各样的编译工具，gcc在程序编译过程中会分别调用它们，常见的工具有预处理器、编译器、汇编器、链接器。

- 预处理器：将源文件main.c经过预处理变为main.i。

- 编译器：将预处理后的main.i编译为汇编文件main.s。

- 汇编器：将汇编文件main.s编译为目标文件main.o。

- 链接器：将各个目标文件main.o、sub.o链接成可执行文件a.out。

  最后生成的可执行文件a.out其实也是目标文件（object file），唯一不同的是，a.out是一种可执行的目标文件。目标文件一般可以分为3种。

- 可重定位的目标文件（relocatable files）。

-  可执行的目标文件（executable files）。

- 可被共享的目标文件（shared object files）。

### 1.2 预处理过程

​		为了方便编程，编译器一般为开发人员提供一些预处理命令，使用＃标识。我们常见的预处理命令如下。

- 头文件包含：#include
- 定义一个宏：#define
- 条件编译:#if,#else,#endif
- 编译控制:#pragma

通过头文件包含可以实现模块化编程；使用宏可以定义一个常量，提高程序的可读性；通过条件编译可以让代码兼容不同的处理器架构和平台，以最大限度地复用公用代码。通过＃pragma预处理命令可以设定编译器的状态，指示编译器完成一些特定的动作。

- #pragma pack([n])：指示结构体和联合成员的对齐方式。
- #pragma message("string")：在编译信息输出窗口打印自己的文本信息。
- #pragma warning:有选择地改变编译器的警告信息行为
- #pragma once:在头文件中添加这条命令，可以防止头文件多次编译。

​        预处理过程，其实就是在编译源程序之前，先处理源文件中的各种预处理命令。编译器是不认识预处理指令的，在编译之前不先把这些预处理命令处理掉，编译器就会报错。预处理主要包括以下操作

- 头文件展开：将#include包含的头文件内容展开到当前位置。
- 宏展开：展开所有的宏定义，并删除#define
- 条件编译：根据宏定义条件，选择要参与编译的分支代码，其余的分支丢弃。
- 删除注释
- 添加行号和文件名标识：编译过程中根据需要可以显示这些信息。
- 保留#pragma命令：该命令会在程序编译时指令编译器执行一些特定行为。



