## 704. 二分查找

[力扣题目链接](https://gitee.com/link?target=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fbinary-search%2F)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

### 示例 1:

```
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4     
```

### 示例 2:

```
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1        
```

### 提示：

- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间。

### 思路

**是数组为有序数组**，同时题目还强调**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，就需要考虑是否需要使用二分法了。



### 实现

- C++实现

```c++
class Solution {
public:
    int search(std::vector<int>& nums, int target) {
        int len = nums.size();
        int left = 0;
        int right = len - 1;
        while (left <= right){
            int middle = left + (right - left) / 2;
            if (nums[middle] > target){
                right = middle - 1;
                continue;
            }
            if (nums[middle] < target){
                left = middle + 1;
            }
            if (nums[middle] == target){
                return middle;
            }
        }
        return -1;
    }
};
```

- C语言实现

```c
int search(int* nums, int numsSize, int target){
    int low = 0 ; 
    int height = numsSize - 1 ;
    int  middle = 0;
    while(low<=height){
        middle = (low+height) / 2;
        if(target > nums[middle]){
            low= middle+1;
            continue;
        }else if(target < nums[middle]){
            height = middle - 1;
            continue;
        }else{
            return middle;
        }
    }
    return -1 ;
}
```



# 35.搜索插入位置

[力扣题目链接(opens new window)](https://leetcode.cn/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

### 示例 1:

- 输入: [1,3,5,6], 5
- 输出: 2

### 示例 2:

- 输入: [1,3,5,6], 2
- 输出: 1

### 示例 3:

- 输入: [1,3,5,6], 7
- 输出: 4

### 示例 4:

- 输入: [1,3,5,6], 0
- 输出: 0

### 思路

要在数组中插入目标值，分为以下四种情况

![image-20221215213800645](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20221215213800645.png)

### 实现

- C++实现

```c++
class Solution {
public:
    int searchInsert(std::vector<int>& nums, int target) {

        int len = nums.size();
        int left = 0;
        if ( target < nums[left]){
            nums.insert(nums.cbegin(),target);
        }
        int right = len - 1;
        if (target > nums[right]){
            nums.insert(nums.cend(),target);
        }
        int middle = 0;
        while (left <= right){
            middle = left + ((right - left) >> 1);
            if (nums[middle] > target){
                right = middle - 1;
                continue;
            }
            if (nums[middle] < target){
                left = middle + 1;
            }
            if (nums[middle] == target){
                return middle;
            }

        }
        if(nums[middle] > target){
            return middle;
        } else{
            return middle - 1;
        }
    }
};
```

