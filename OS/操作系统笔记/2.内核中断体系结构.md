# 内核中断体系结构

```
目的:
	1. 硬件的中断响应---->内核驱动中的中断
	2. 系统调用和函数响应(sys_call)---->系统调用
	3. 自定义中断---->软件的软中断模式
	4. 信号中断(kill -signalnum)---->对了解信号的使用 创建等
	5. 系统的异常和错误---->系统的异常获取 了解系统异常的作用
```



## 1.Linux中断机制

### 1.1 分类: 硬件中断和软件中断

**硬件中断**

- 由电脑主机的8259类似的硬件中断控制芯片发出的中断
- ARM中断控制器发出的中断

**软件中断**:异常

- CPU自行保存的中断
- 系统调用异常

### 1.2 代码结构

```
asm.s					trap.c
system_call.s			fork.c	signal.c exit.c sys.c
```



## 2.中断工作流程

### 2.1 中断处理流程

- 做CPU工作状态的转化（通过寄存来完成）
- 进行寄存器的拷贝与压栈
- 设置中断异常向量表
- 保存正常运行的函数返回值
- 跳转到对应中断服务函数上运行
- 进行模式的复原以及寄存器的复原
- 跳转回正常工作的函数地址继续运行

### 2.2 Linux中中断的工作流程

- 将所有的寄存器值入栈

  ```
  8086:SS EFLAGS ESP CS EIP (错误码)
  ARM:(r0-r15)
  ```

- 将异常码入栈（也就是中断号压入栈）

- 将当前函数的返回地址进行入栈(为了在中断执行后还能够找回从哪里中断的，能够复原)

- 调用对应的中断服务函数(中断请求已经完事了)

- 出栈被中断函数的返回地址

- 返回所有入栈的寄存器

![中断流程.drawio](https://raw.githubusercontent.com/bigshcool/myPic/main/%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B.drawio.png)

| 中断处理方式             | 中断前的处理过程与中断的恢复过程 | 中断的执行过程               |
| ------------------------ | -------------------------------- | ---------------------------- |
| 硬件中断                 | asm.s                            | trap.c                       |
| 软件以及系统调用处理过程 | system_call.s                    | fork.c signal.c exit.c sys.c |



问题**异常码的作用是什么:**

这里的异常码是中断号，中断处理过程中的c代码还要靠这个号找到中断处理函数



## 3. 硬件中断的代码实现过程

发生中断了，产生了中断响应，需要执行以下步骤:

- 关中断:中断是指当出现需要时，CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。即在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU暂时中止程序的执行转而处理这个新的情况的过程就叫做中断。而关中断是指在此中断处理完成前，不处理其它中断.
- 保存断点（将EFLAGS，CS，EIP依次压栈）
- 识别中断源:通过某种方式，CPU获取的**中断服务程序的`CS:EIP`**，然后再转跳到no_error_code或者error_code
  - no_error_code(此时汇编发挥作用)
    - 保护现场
    - 执行中断处理程序
    - 恢复现场和返回原程序
  - error_code

```
/*
 * asm.s contains the low-level code for most hardware faults.
 * page_exception is handled by the mm, so that isn't here. This
 * file also handles (hopefully) fpu-exceptions due to TS-bit, as
 * the fpu must be properly saved/resored. This hasn't been tested.
 */

.globl _divide_error,_debug,_nmi,_int3,_overflow,_bounds,_invalid_op
.globl _device_not_available,_double_fault,_coprocessor_segment_overrun
.globl _invalid_TSS,_segment_not_present,_stack_segment
.globl _general_protection,_coprocessor_error,_reserved

# 中断处理函数的调用C函数入口地址，进行压栈
_divide_error:
	pushl $_do_divide_error
no_error_code:
# 将esp与eax中的值进行交换，此时eax中存放的是中断处理函数的地址
# 注意:esp此时指向的是c函数入口地址
# 经过命令交换后，esp->eax,而exp原有的c语言地址又给了eax
# 最后就变成了,esp->eax->中断程序入口
	xchgl %eax,(%esp)
# 保存各种各样的通用寄存器
	pushl %ebx
	pushl %ecx
	pushl %edx
# 保存esi，edi变址寄存器
	pushl %edi
	pushl %esi
	pushl %ebp
# 占用4个字节
	push %ds
	push %es
	push %fs
# 没有错误码，则压入0进行占位
	pushl $0		# "error code"
# 将esp的值上移44个字节，也就是上移11个格子，然后取内容(此时保存的是原来函数的地址)，将其赋值给edx寄存器
	lea 44(%esp),%edx
# 然后将寄存器压入栈中
	pushl %edx
# 设置内核数据段选择符，设置好数据寻址的基址
	movl $0x10,%edx
	mov %dx,%ds
	mov %dx,%es
	mov %dx,%fs
# 调用c中断处理函数入口
	call *%eax
# 恢复现场
# 加了八个字节进行出栈
	addl $8,%esp
	pop %fs
	pop %es
	pop %ds
	popl %ebp
	popl %esi
	popl %edi
	popl %edx
	popl %ecx
	popl %ebx
	popl %eax
	iret

_debug:
	pushl $_do_int3		# _do_debug
	jmp no_error_code

_nmi:
	pushl $_do_nmi
	jmp no_error_code

_int3:
	pushl $_do_int3
	jmp no_error_code

_overflow:
	pushl $_do_overflow
	jmp no_error_code

_bounds:
	pushl $_do_bounds
	jmp no_error_code

_invalid_op:
	pushl $_do_invalid_op
	jmp no_error_code

math_emulate:
	popl %eax
	pushl $_do_device_not_available
	jmp no_error_code
_device_not_available:
	pushl %eax
	movl %cr0,%eax
	bt $2,%eax			# EM (math emulation bit)
	jc math_emulate
	clts				# clear TS so that we can use math
	movl _current,%eax
	cmpl _last_task_used_math,%eax
	je 1f				# shouldn't happen really ...
	pushl %ecx
	pushl %edx
	push %ds
	movl $0x10,%eax
	mov %ax,%ds
	call _math_state_restore
	pop %ds
	popl %edx
	popl %ecx
1:	popl %eax
	iret

_coprocessor_segment_overrun:
	pushl $_do_coprocessor_segment_overrun
	jmp no_error_code

_reserved:
	pushl $_do_reserved
	jmp no_error_code

_coprocessor_error:
	pushl $_do_coprocessor_error
	jmp no_error_code

_double_fault:
	pushl $_do_double_fault
error_code:
	xchgl %eax,4(%esp)		# error code <-> %eax
	xchgl %ebx,(%esp)		# &function <-> %ebx
	pushl %ecx
	pushl %edx
	pushl %edi
	pushl %esi
	pushl %ebp
	push %ds
	push %es
	push %fs
	pushl %eax			# error code
	lea 44(%esp),%eax		# offset
	pushl %eax
	movl $0x10,%eax
	mov %ax,%ds
	mov %ax,%es
	mov %ax,%fs
	call *%ebx
	addl $8,%esp
	pop %fs
	pop %es
	pop %ds
	popl %ebp
	popl %esi
	popl %edi
	popl %edx
	popl %ecx
	popl %ebx
	popl %eax
	iret

_invalid_TSS:
	pushl $_do_invalid_TSS
	jmp error_code

_segment_not_present:
	pushl $_do_segment_not_present
	jmp error_code

_stack_segment:
	pushl $_do_stack_segment
	jmp error_code

_general_protection:
	pushl $_do_general_protection
	jmp error_code


```



![image-20221201162755003](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20221201162755003.png)

**iret:**中断门或陷阱门中断服务例程的返回，按照之前入栈的相反顺序将EIP、CS先后出栈；再将EFLAGS标志寄存器出栈，恢复现场(IRET指令)。

简而言之，就是把最开始保存断点的部分**依次出栈**，从而回到源程序