# 内核中断体系结构

```
目的:
	1. 硬件的中断响应---->内核驱动中的中断
	2. 系统调用和函数响应(sys_call)---->系统调用
	3. 自定义中断---->软件的软中断模式
	4. 信号中断(kill -signalnum)---->对了解信号的使用 创建等
	5. 系统的异常和错误---->系统的异常获取 了解系统异常的作用
```



## 1.Linux中断机制

### 1.1 分类: 硬件中断和软件中断

**硬件中断**

- 由电脑主机的8259类似的硬件中断控制芯片发出的中断
- ARM中断控制器发出的中断

**软件中断**:异常

- CPU自行保存的中断
- 系统调用异常

### 1.2 代码结构

```
asm.s					trap.c
system_call.s			fork.c	signal.c exit.c sys.c
```



## 2.中断工作流程

### 2.1 中断处理流程

- 做CPU工作状态的转化（通过寄存来完成）
- 进行寄存器的拷贝与压栈
- 设置中断异常向量表
- 保存正常运行的函数返回值
- 跳转到对应中断服务函数上运行
- 进行模式的复原以及寄存器的复原
- 跳转回正常工作的函数地址继续运行

### 2.2 Linux中中断的工作流程

- 将所有的寄存器值入栈

  ```
  8086:SS EFLAGS ESP CS EIP (错误码)
  ARM:(r0-r15)
  ```

- 将异常码入栈（也就是中断号压入栈）

- 将当前函数的返回地址进行入栈(为了在中断执行后还能够找回从哪里中断的，能够复原)

- 调用对应的中断服务函数(中断请求已经完事了)

- 出栈被中断函数的返回地址

- 返回所有入栈的寄存器

![中断流程.drawio](https://raw.githubusercontent.com/bigshcool/myPic/main/%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B.drawio.png)

| 中断处理方式             | 中断前的处理过程与中断的恢复过程 | 中断的执行过程               |
| ------------------------ | -------------------------------- | ---------------------------- |
| 硬件中断                 | asm.s                            | trap.c                       |
| 软件以及系统调用处理过程 | system_call.s                    | fork.c signal.c exit.c sys.c |



问题**异常码的作用是什么:**

这里的异常码是中断号，中断处理过程中的c代码还要靠这个号找到中断处理函数



## 3. 硬件中断的代码实现过程

发生中断了，产生了中断响应，需要执行以下步骤:

- 关中断:中断是指当出现需要时，CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。即在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU暂时中止程序的执行转而处理这个新的情况的过程就叫做中断。而关中断是指在此中断处理完成前，不处理其它中断.
- 保存断点（将EFLAGS，CS，EIP依次压栈）
- 识别中断源:通过某种方式，CPU获取的**中断服务程序的`CS:EIP`**，然后再转跳到no_error_code或者error_code
  - no_error_code(此时汇编发挥作用)
    - 保护现场
    - 执行中断处理程序
    - 恢复现场和返回原程序
  - error_code

- asm.s代码

```
/*
 * asm.s contains the low-level code for most hardware faults.
 * page_exception is handled by the mm, so that isn't here. This
 * file also handles (hopefully) fpu-exceptions due to TS-bit, as
 * the fpu must be properly saved/resored. This hasn't been tested.
 */

.globl _divide_error,_debug,_nmi,_int3,_overflow,_bounds,_invalid_op
.globl _device_not_available,_double_fault,_coprocessor_segment_overrun
.globl _invalid_TSS,_segment_not_present,_stack_segment
.globl _general_protection,_coprocessor_error,_reserved

# 中断处理函数的调用C函数入口地址，进行压栈
_divide_error:
	pushl $_do_divide_error
no_error_code:
# 将esp与eax中的值进行交换，此时eax中存放的是中断处理函数的地址
# 注意:esp此时指向的是c函数入口地址
# 经过命令交换后，esp->eax,而exp原有的c语言地址又给了eax
# 最后就变成了,esp->eax->中断程序入口
	xchgl %eax,(%esp)
# 保存各种各样的通用寄存器
	pushl %ebx
	pushl %ecx
	pushl %edx
# 保存esi，edi变址寄存器
	pushl %edi
	pushl %esi
	pushl %ebp
# 占用4个字节
	push %ds
	push %es
	push %fs
# 没有错误码，则压入0进行占位
	pushl $0		# "error code"
# 将esp的值上移44个字节，也就是上移11个格子，然后取内容(此时保存的是原来函数的地址)，将其赋值给edx寄存器
	lea 44(%esp),%edx
# 然后将寄存器压入栈中
	pushl %edx
# 设置内核数据段选择符，设置好数据寻址的基址
	movl $0x10,%edx
	mov %dx,%ds
	mov %dx,%es
	mov %dx,%fs
# 调用c中断处理函数入口
	call *%eax
# 恢复现场
# 加了八个字节进行出栈
	addl $8,%esp
	pop %fs
	pop %es
	pop %ds
	popl %ebp
	popl %esi
	popl %edi
	popl %edx
	popl %ecx
	popl %ebx
	popl %eax
	iret

_debug:
	pushl $_do_int3		# _do_debug
	jmp no_error_code

_nmi:
	pushl $_do_nmi
	jmp no_error_code

_int3:
	pushl $_do_int3
	jmp no_error_code

_overflow:
	pushl $_do_overflow
	jmp no_error_code

_bounds:
	pushl $_do_bounds
	jmp no_error_code

_invalid_op:
	pushl $_do_invalid_op
	jmp no_error_code

math_emulate:
	popl %eax
	pushl $_do_device_not_available
	jmp no_error_code
_device_not_available:
	pushl %eax
	movl %cr0,%eax
	bt $2,%eax			# EM (math emulation bit)
	jc math_emulate
	clts				# clear TS so that we can use math
	movl _current,%eax
	cmpl _last_task_used_math,%eax
	je 1f				# shouldn't happen really ...
	pushl %ecx
	pushl %edx
	push %ds
	movl $0x10,%eax
	mov %ax,%ds
	call _math_state_restore
	pop %ds
	popl %edx
	popl %ecx
1:	popl %eax
	iret

_coprocessor_segment_overrun:
	pushl $_do_coprocessor_segment_overrun
	jmp no_error_code

_reserved:
	pushl $_do_reserved
	jmp no_error_code

_coprocessor_error:
	pushl $_do_coprocessor_error
	jmp no_error_code

_double_fault:
	pushl $_do_double_fault
error_code:
	xchgl %eax,4(%esp)		# error code <-> %eax
	xchgl %ebx,(%esp)		# &function <-> %ebx
	pushl %ecx
	pushl %edx
	pushl %edi
	pushl %esi
	pushl %ebp
	push %ds
	push %es
	push %fs
	pushl %eax			# error code
	lea 44(%esp),%eax		# offset
	pushl %eax
	movl $0x10,%eax
	mov %ax,%ds
	mov %ax,%es
	mov %ax,%fs
	call *%ebx
	addl $8,%esp
	pop %fs
	pop %es
	pop %ds
	popl %ebp
	popl %esi
	popl %edi
	popl %edx
	popl %ecx
	popl %ebx
	popl %eax
	iret

_invalid_TSS:
	pushl $_do_invalid_TSS
	jmp error_code

_segment_not_present:
	pushl $_do_segment_not_present
	jmp error_code

_stack_segment:
	pushl $_do_stack_segment
	jmp error_code

_general_protection:
	pushl $_do_general_protection
	jmp error_code


```



![image-20221201162755003](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20221201162755003.png)

**iret:**中断门或陷阱门中断服务例程的返回，按照之前入栈的相反顺序将EIP、CS先后出栈；再将EFLAGS标志寄存器出栈，恢复现场(IRET指令)。

简而言之，就是把最开始保存断点的部分**依次出栈**，从而回到源程序

- praps.c

traps的主要功能：其函数被asm.s中调用打印[中断](https://so.csdn.net/so/search?q=中断&spm=1001.2101.3001.7020)信息，通过set_trap_gate设置中断向量（如：set_trap_gate(0,÷_error);），c语言中写汇编。

```c
/*
 *  linux/kernel/traps.c
 *
 *  (C) 1991  Linus Torvalds
 */

/*
 * 'Traps.c' handles hardware traps and faults after we have saved some
 * state in 'asm.s'. Currently mostly a debugging-aid, will be extended
 * to mainly kill the offending process (probably by giving it a signal,
 * but possibly by killing it outright if necessary).
 */
#include <string.h>

#include <linux/head.h>
#include <linux/sched.h>
#include <linux/kernel.h>
#include <asm/system.h>
#include <asm/segment.h>
#include <asm/io.h>

//得到段寄存器中addr 地址的数据,返回一个字节
#define get_seg_byte(seg,addr) ({ \
register char __res; \
__asm__("push %%fs;mov %%ax,%%fs;movb %%fs:%2,%%al;pop %%fs" \
        :"=a" (__res):"" (seg),"m" (*(addr))); \
__res;})

//返回四个字节的addr 地址的段寄存器内容
#define get_seg_long(seg,addr) ({ \
register unsigned long __res; \
__asm__("push %%fs;mov %%ax,%%fs;movl %%fs:%2,%%eax;pop %%fs" \
        :"=a" (__res):"" (seg),"m" (*(addr))); \
__res;})
//取得fs 段寄存器的内容
#define _fs() ({ \
register unsigned short __res; \
__asm__("mov %%fs,%%ax":"=a" (__res):); \
__res;})

int do_exit(long code);

void page_exception(void);

void divide_error(void);
void debug(void);
void nmi(void);
void int3(void);
void overflow(void);
void bounds(void);
void invalid_op(void);
void device_not_available(void);
void double_fault(void);
void coprocessor_segment_overrun(void);
void invalid_TSS(void);
void segment_not_present(void);
void stack_segment(void);
void general_protection(void);
void page_fault(void);
void coprocessor_error(void);
void reserved(void);
void parallel_interrupt(void);
void irq13(void);

// 定义的die函数打印信息
// 用来打印出错中断的名称、出错号、调用程序的EIP、EFLAGS、ESP、fs 段寄存器值、
// 段的基址、段的长度、进程号pid、任务号、10 字节指令码。如果堆栈在用户数据段，则还
// 打印16 字节的堆栈内容。
static void die(char * str,long esp_ptr,long nr)

    	// 获取栈顶的位置
        long * esp = (long *) esp_ptr;
        int i;
		// 段地址求与，并且按照16进制输出4个字节的十进制数
        printk("%s: %04x\n\r",str,nr&0xffff);
        printk("EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n",
                esp[1],esp[0],esp[2],esp[4],esp[3]);
		// 打印段寄存器的内容
        printk("fs: %04x\n",_fs());
        printk("base: %p, limit: %p\n",get_base(current->ldt[1]),get_limit(0x17));
        if (esp[4] == 0x17) {
                printk("Stack: ");
                for (i=0;i<4;i++)
                    	// 从段中取一个四字节的整数
                        printk("%p ",get_seg_long(0x17,i+(long *)esp[3]));
                printk("\n");
        }
        str(i);
        printk("Pid: %d, process nr: %d\n\r",current->pid,0xffff & i);
        for(i=0;i<10;i++)
                printk("%02x ",0xff & get_seg_byte(esp[1],(i+(char *)esp[0])));
        printk("\n\r");
        do_exit(11);            /* play segment exception */
}

void do_double_fault(long esp, long error_code)
{
        die("double fault",esp,error_code);
}

void do_general_protection(long esp, long error_code)
{
        die("general protection",esp,error_code);
}

void do_divide_error(long esp, long error_code)
{
        die("divide error",esp,error_code);
}

void do_int3(long * esp, long error_code,
                long fs,long es,long ds,
                long ebp,long esi,long edi,
                long edx,long ecx,long ebx,long eax)
{
        int tr;

        __asm__("str %%ax":"=a" (tr):"" (0));
        printk("eax\t\tebx\t\tecx\t\tedx\n\r%8x\t%8x\t%8x\t%8x\n\r",
                eax,ebx,ecx,edx);
        printk("esi\t\tedi\t\tebp\t\tesp\n\r%8x\t%8x\t%8x\t%8x\n\r",
                esi,edi,ebp,(long) esp);
        printk("\n\rds\tes\tfs\ttr\n\r%4x\t%4x\t%4x\t%4x\n\r",
                ds,es,fs,tr);
        printk("EIP: %8x   CS: %4x  EFLAGS: %8x\n\r",esp[0],esp[1],esp[2]);
}

void do_nmi(long esp, long error_code)
{
        die("nmi",esp,error_code);
}

void do_debug(long esp, long error_code)
{
        die("debug",esp,error_code);
}

void do_overflow(long esp, long error_code)
{
        die("overflow",esp,error_code);
}

void do_bounds(long esp, long error_code)
{
        die("bounds",esp,error_code);
}

void do_invalid_op(long esp, long error_code)
{
        die("invalid operand",esp,error_code);
}

void do_device_not_available(long esp, long error_code)
{
        die("device not available",esp,error_code);
}

void do_coprocessor_segment_overrun(long esp, long error_code)
{
        die("coprocessor segment overrun",esp,error_code);
}

void do_invalid_TSS(long esp,long error_code)
{
        die("invalid TSS",esp,error_code);
}

void do_segment_not_present(long esp,long error_code)
{
        die("segment not present",esp,error_code);
}

void do_stack_segment(long esp,long error_code)
{
        die("stack segment",esp,error_code);
}

void do_coprocessor_error(long esp, long error_code)
{
        if (last_task_used_math != current)
                return;
        die("coprocessor error",esp,error_code);
}

void do_reserved(long esp, long error_code)
{
        die("reserved (15,17-47) error",esp,error_code);
}

// set_trap_gate 设置的权限较高，只能由用户程序调用
// set_system_gate 设置的权限较低，能由用户和系统调用
void trap_init(void)
{
        int i;
		// 除以0的时候会产生的中断
        set_trap_gate(0,&divide_error);
        // 单步调试的产生的中断
    	set_trap_gate(1,&debug);
    	// 由不可屏蔽会产生的中断
        set_trap_gate(2,&nmi);
    	// 也代表单步中断
        set_system_gate(3,&int3);       /* int3-5 can be called from all */
        // 溢出的会出现中断
    	set_system_gate(4,&overflow);
    	set_system_gate(5,&bounds);
        set_trap_gate(6,&invalid_op);
        set_trap_gate(7,&device_not_available);
        set_trap_gate(8,&double_fault);
        set_trap_gate(9,&coprocessor_segment_overrun);
        set_trap_gate(10,&invalid_TSS);
        set_trap_gate(11,&segment_not_present);
        set_trap_gate(12,&stack_segment);
        set_trap_gate(13,&general_protection);
        set_trap_gate(14,&page_fault);
        set_trap_gate(15,&reserved);
        set_trap_gate(16,&coprocessor_error);
        for (i=17;i<48;i++)
                set_trap_gate(i,&reserved);
        set_trap_gate(45,&irq13);
        outb_p(inb_p(0x21)&0xfb,0x21);
        outb(inb_p(0xA1)&0xdf,0xA1);
        set_trap_gate(39,&parallel_interrupt);
}
```

