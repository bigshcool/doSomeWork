# 系统的进程管理

## 1.系统进程的运转方式

### 1.1 系统时间(jiffies 系统滴答)

CPU内部会有一个RTC计时器，会在系统上电的时候调用mktime.c，算出1970年1月1日0时开始到当前开机点所过的秒数。以下是**mktime.c文件**,他会由main方法中的init_time函数调用，并且rtc所读的时间将会被传参。它所传递出来的结果将会被jiffies所使用。

```c
#include <time.h>

/*
 * This isn't the library routine, it is only used in the kernel.
 * as such, we don't care about years<1970 etc, but assume everything
 * is ok. Similarly, TZ etc is happily ignored. We just do everything
 * as easily as possible. Let's find something public for the library
 * routines (although I think minix times is public).
 */
/*
 * PS. I hate whoever though up the year 1970 - couldn't they have gotten
 * a leap-year instead? I also hate Gregorius, pope or no. I'm grumpy.
 */
// 宏定义的作用是计算一年中有多少秒
#define MINUTE 60
#define HOUR (60*MINUTE)
#define DAY (24*HOUR)
#define YEAR (365*DAY)

/* interestingly, we assume leap-years */
static int month[12] = {
	0,
	DAY*(31),
	DAY*(31+29),
	DAY*(31+29+31),
	DAY*(31+29+31+30),
	DAY*(31+29+31+30+31),
	DAY*(31+29+31+30+31+30),
	DAY*(31+29+31+30+31+30+31),
	DAY*(31+29+31+30+31+30+31+31),
	DAY*(31+29+31+30+31+30+31+31+30),
	DAY*(31+29+31+30+31+30+31+31+30+31),
	DAY*(31+29+31+30+31+30+31+31+30+31+30)
};

// 这里传来的时间结构体赋值是由从RTC或者coms中读出来的
// 他会计算1970年以来的时间
long kernel_mktime(struct tm * tm)
{
	long res;
	int year;

	year = tm->tm_year - 70;
/* magic offsets (y+1) needed to get leapyears right.*/
	res = YEAR*year + DAY*((year+1)/4);
	res += month[tm->tm_mon];
/* and (y+2) here. If it wasn't a leap-year, we have to adjust */
	if (tm->tm_mon>1 && ((year+2)%4))
		res -= DAY;
	res += DAY*(tm->tm_mday-1);
	res += HOUR*tm->tm_hour;
	res += MINUTE*tm->tm_min;
	res += tm->tm_sec;
	return res;
}
```

**JIFFIES是一个系统嘀嗒，一个嘀嗒是10ms，相当于一个而定时器，它会引发定时器中断_timer_interrupt,其中会有incl _jiffies进行自增，然后调用**call _do_timer函数

```
// system_call.s 

.align 2
_timer_interrupt:
	push %ds		# save ds,es and put kernel data space
	push %es		# into them. %fs is used by _system_call
	push %fs
	pushl %edx		# we save %eax,%ecx,%edx as gcc doesn't
	pushl %ecx		# save those across function calls. %ebx
	pushl %ebx		# is saved as we use that in ret_sys_call
	pushl %eax
	movl $0x10,%eax
	mov %ax,%ds
	mov %ax,%es
	movl $0x17,%eax
	mov %ax,%fs
	incl _jiffies
	movb $0x20,%al		# EOI to interrupt controller #1
	outb %al,$0x20
	movl CS(%esp),%eax
	andl $3,%eax		# %eax is CPL (0 or 3, 0=supervisor)
	pushl %eax
	call _do_timer		# 'do_timer(long CPL)' does everything from
	addl $4,%esp		# task switching to accounting ...
	jmp ret_from_sys_call
```



```c
// sched.c 中do_timer
// cpl用来指示被中断程序的程序的特权
// 0表示是内核进程
// 1表示的中断进行是用户进程
// current 是一个 task_struct 变量,保存进程的相关信息，一个task_struct就代表一个进程
// counter代表时间片
// 进程的调度其实就是task_struck[]进程链表检索，找时间片最大的那个进程对象（task_struck）,然后在进行调用
// 当所有的进程的时间片用完了就会调用schedule，再次进行时间片的分配
// linux 0.0.1内核采用的是优先级时间片进行轮转的方式进行调度。
void do_timer(long cpl)
{
	if (cpl)
        // 用户进程的运行时间
		current->utime++;
	else
        // 内核程序的运行时间
		current->stime++;
    // counter  --- > 进程的时间片
	if ((--current->counter)>0) return;
	current->counter=0;
    // 是内核状态就退出
	if (!cpl) return;
    // 进行时间片分配
	schedule();
}
```





```c
// sys.c 中 sys_time将当前时间放在段内存中，然后返回一个jiddies
int sys_times(struct tms * tbuf)
{
	if (!tbuf)
		return jiffies;
	verify_area(tbuf,sizeof *tbuf);
	put_fs_long(current->utime,(unsigned long *)&tbuf->tms_utime);
	put_fs_long(current->stime,(unsigned long *)&tbuf->tms_stime);
	put_fs_long(current->cutime,(unsigned long *)&tbuf->tms_cutime);
	put_fs_long(current->cstime,(unsigned long *)&tbuf->tms_cstime);
	return jiffies;
}
```



## 2. 如何进行创建一个新的进程



## 3.如何调度



## 4. 进程的退出



## 5. 进程间的通信

