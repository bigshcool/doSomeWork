# 原子操作类

![image-20230403114913044](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230403114913044.png)

## 1.类型

### 1.1 基本类型原子类

- **AtomicInteger**
- **AtomicBoolean**
- **AtomicLong**

#### 1.1.1 常用API 简介

```java
public final int get()//获取当前的值
public final int getAndSet(int newvalue)//获取当前的值，并设置新的值
public final int getAndIncrement()//获取当前的值，并自增
public final int getAndDecrement()/获取当前的值，并自减
public final int getAndAdd(int delta)//获取当前的值，并加上预期的值
public final void lazySet(int newWValue)/I最终设置为newValue,使用lazySset 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的信。
```

#### 1.1.2 代码区展示

```java
import java.util.concurrent.atomic.AtomicInteger;

class MyNumber{
    AtomicInteger atomicInteger = new AtomicInteger();

    public void addPlusPlus(){
        atomicInteger.getAndIncrement();
    }
}

public class AtomicIntegerDemo {
    public static final int size =50;
    public static void main(String[] args) {

        MyNumber myNumber = new MyNumber();

        for (int i = 1; i <= size ; i++){
            new Thread(()->{
                for (int j = 1; j <= 1000;  j++){
                    myNumber.addPlusPlus();
                }
            },String.valueOf(i)).start();
        }
		// 按道理来说是应该输出50000的
        // 但是由于主线程在线程1 - 50 之间的没有运行完成的时候就get到了值
        System.out.println(Thread.currentThread().getName() + "\t" + "result : " + myNumber.atomicInteger.get());
    }
}
```

![image-20230403120717345](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230403120717345.png)

- 引入CountDownLatch

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;

class MyNumber{
    AtomicInteger atomicInteger = new AtomicInteger();

    public void addPlusPlus(){
        atomicInteger.getAndIncrement();
    }
}

public class AtomicIntegerDemo {
    public static final int size =50;

    public static void main(String[] args) throws InterruptedException {

        MyNumber myNumber = new MyNumber();
        CountDownLatch countDownLatch = new CountDownLatch(size);

        for (int i = 1; i <= size ; i++){
            new Thread(()->{
                try {
                    for (int j = 1; j <= 1000;  j++){
                        myNumber.addPlusPlus();
                    }
                }finally {
                    countDownLatch.countDown();
                }
            },String.valueOf(i)).start();
        }

        countDownLatch.await();
        System.out.println(Thread.currentThread().getName() + "\t" + "result : " + myNumber.atomicInteger.get());
 }
```

![image-20230403151354400](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230403151354400.png)

### 1.2 数组类型原子类

- **AtomicUbtegerArray**

#### 1.2.1. 代码区展示

```java
import java.util.concurrent.atomic.AtomicIntegerArray;

public class AtomicIntegerArrayDemo {
    public static void main(String[] args) {
        // 构造方法1
        AtomicIntegerArray atomicIntegerArray1 = new AtomicIntegerArray(new int[5]);

        // 构造方法2
        AtomicIntegerArray atomicIntegerArray2 = new AtomicIntegerArray(5);

        // 构造方法3
        AtomicIntegerArray atomicIntegerArray3 = new AtomicIntegerArray(new int[]{1,2,3,4,5});

        for (int i = 0; i < atomicIntegerArray1.length(); i++){
            System.out.println(atomicIntegerArray1.get(i));
        }

        System.out.println("--------------------------------------------------");

        for (int i = 0; i < atomicIntegerArray2.length(); i++){
            System.out.println(atomicIntegerArray2.get(i));
        }

        System.out.println("--------------------------------------------------");

        for (int i = 0; i < atomicIntegerArray3.length(); i++){
            System.out.println(atomicIntegerArray3.get(i));
        }
        System.out.println("--------------------------------------------------");
        int tempInt = 0;

        tempInt = atomicIntegerArray1.getAndSet(0,1122);
        System.out.println(tempInt + "\t" + atomicIntegerArray1.get(0));

        tempInt = atomicIntegerArray1.getAndIncrement(0);
        System.out.println(tempInt + "\t" + atomicIntegerArray1.get(0));
    }
}
```

![image-20230403152739593](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230403152739593.png)

### 1.3 引用类型原子类

- **AtomicReference**
- **AtomicStampedRefeference**
- **AtomicMarkableReference**

#### 1.3.1 代码区展示

- **AtomicReference**

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
/**
 * 题目：实现一个自旋锁，复习CAS思想
 * 自旋锁好处：循环比较获取没有类似wait的阻塞
 *
 * 通过CAS操作完成自旋锁，A线程先进来调用myLock放啊自己持有锁5秒钟，B随后进来发现
 * 当前有线程持有锁，所以只能通过自旋锁等待，知道A释放锁后B随后抢到。
 * */
public class SpinLockDemo {
    AtomicReference<Thread> atomicReference = new AtomicReference<>();

    public void lock(){
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + "\t" +"----come in");
        while (!atomicReference.compareAndSet(null,thread)){

        }
    }

    public void unlock(){
        Thread thread = Thread.currentThread();
        atomicReference.compareAndSet(thread,null);
        System.out.println(Thread.currentThread().getName() + "\t" + "—————————task over");
    }

    public static void main(String[] args) {
        SpinLockDemo spinLockDemo = new SpinLockDemo();

        new Thread(()->{
            spinLockDemo.lock();
            // 暂停几秒钟线程
            try {
                TimeUnit.SECONDS.sleep(5);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            spinLockDemo.unlock();
        },"A").start();

        // 暂停500毫秒，线程A先于B启动
        try {
            TimeUnit.SECONDS.sleep(5);
        }catch (InterruptedException e){
            e.printStackTrace();
        }

        new Thread(()->{
            spinLockDemo.lock();
            // 暂停几秒钟线程
            try {
                TimeUnit.SECONDS.sleep(5);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            spinLockDemo.unlock();
        },"B").start();
    }
}
```

![image-20230401224143985](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230401224143985.png)

- **AtomicStampedRefeference**

```java
import java.util.concurrent.atomic.AtomicStampedReference;

class Book{
    private int id;
    private String bookName;

    public Book(){

    }

    public Book(int id, String bookName) {
        this.id = id;
        this.bookName = bookName;
    }

    public int getId() {
        return id;
    }

    public String getBookName() {
        return bookName;
    }

    public void setId(int id) {
        this.id = id;
    }

    public void setBookName(String bookName) {
        this.bookName = bookName;
    }

    @Override
    public String toString() {
        return "Book{" +
                "id=" + id +
                ", bookName='" + bookName + '\'' +
                '}';
    }
}

public class AtomicStampeDemo {
    public static void main(String[] args) {
        Book javaBook = new Book(1,"javaBook");

        AtomicStampedReference<Book> stampedReference = new AtomicStampedReference<>(javaBook,1);

        System.out.println(stampedReference.getReference() + "\t" + stampedReference.getStamp());

        Book mysqlBook = new Book(2, "mysqlBook");

        boolean b = stampedReference.compareAndSet(javaBook, mysqlBook, stampedReference.getStamp(), stampedReference.getStamp() + 1);

        System.out.println(b + "\t" + stampedReference.getReference() + "\t" + stampedReference.getStamp());

        b = stampedReference.compareAndSet(mysqlBook, javaBook, stampedReference.getStamp(), stampedReference.getStamp() + 1);

        System.out.println(b + "\t" + stampedReference.getReference() + "\t" + stampedReference.getStamp());
    }
}
```

![image-20230401234534811](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230401234534811.png)

- **AtomicMarkableReference**

  AtomicStampedReference,多次，version+1;

  AtomicMarkableReference,一次，false -> true;

  ```java
  public class AtomicMarkableReferenceDemo {
      static AtomicMarkableReference markableReference = new AtomicMarkableReference(100, false);
  
      public static void main(String[] args) {
          new Thread( ()-> {
              boolean marked = markableReference.isMarked();
              System.out.println(Thread.currentThread().getName() + "\t" + "默认标识为:" + marked);
              // 暂停1秒钟线程，等待后面的T2线程和我拿到一样的模式flag标识，都是false
              try {
                  TimeUnit.SECONDS.sleep(1);
              }catch (InterruptedException e){
                  e.printStackTrace();
              }
              boolean b = markableReference.compareAndSet(100, 1000, marked, !marked);
              System.out.println(Thread.currentThread().getName() + "\t " + b);
              System.out.println(Thread.currentThread().getName() + "\t " + markableReference.isMarked());
              System.out.println(Thread.currentThread().getName() + "\t " + markableReference.getReference());
          },"t1").start();
  
          new Thread( ()-> {
              boolean marked = markableReference.isMarked();
              System.out.println(Thread.currentThread().getName() + "\t" + "默认标识为:" + marked);
              // 暂停1秒钟线程，等待后面的T2线程和我拿到一样的模式flag标识，都是false
              try {
                  TimeUnit.SECONDS.sleep(2);
              }catch (InterruptedException e){
                  e.printStackTrace();
              }
              boolean b = markableReference.compareAndSet(100, 2022, marked, !marked);
  
              System.out.println(Thread.currentThread().getName() + "\t " + b);
              System.out.println(Thread.currentThread().getName() + "\t " + markableReference.isMarked());
              System.out.println(Thread.currentThread().getName() + "\t " + markableReference.getReference());
          },"t2").start();
      }
  }
  ```

### 1.4 对象的属性修改原子类(更加细粒度)

- **AtomicIntegerFieldUpdater:原子更新对象中int类型字段的值，基于反射的实用程序，可以对指定类的volatile int字段进行原子更新**
- **AtomicLongFieldUpdater:原子更新对象中Long类型字段的值，可以对指定类的volatile long进行原子更新**
- **AtomicReferenceFieldUpdater:原子更新引用类型字段的值，可以对指令类的指定volatile引用字段进行原子更新**

#### 1.4.1 使用目的

以一种线程安全的方式操作非线程安全对象内的某些字段，相当于更小粒度的原子操作。

#### 1.4.2 使用要求

- 更新的对象属性**必须使用public volatile修饰符**
- 因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的值。

#### 1.4.3 代码区展示

- 使用synchronized

```java
// 资源类
class BankAccount{
    String bankName = "CCB";

    int money = 0; // 钱数

    public synchronized void add(){
        money++;
    }
}

public class AtomicIntegerFieldUpdater {
    public static void main(String[] args) {
        BankAccount bankAccount = new BankAccount();
        CountDownLatch countDownLatch = new CountDownLatch(10);

        for (int i = 1; i <= 10; i++){
            new Thread(()->{
                try {
                    for (int j = 1; j <= 1000; j++){
                        bankAccount.add();
                    }
                }finally {
                    countDownLatch.countDown();
                }
            },String.valueOf(i)).start();
        }

        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(bankAccount.money);
    }
}
```

![image-20230403165212205](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230403165212205.png)

- 不使用synchronized

```java
// 资源类
class BankAccount{
    String bankName = "CCB";

    int money = 0; // 钱	
	// 去掉synchronized
    public  void add(){
        money++;
    }
}

public class AtomicIntegerFieldUpdater {
    public static void main(String[] args) {
        BankAccount bankAccount = new BankAccount();
        CountDownLatch countDownLatch = new CountDownLatch(10);

        for (int i = 1; i <= 10; i++){
            new Thread(()->{
                try {
                    for (int j = 1; j <= 1000; j++){
                        bankAccount.add();
                    }
                }finally {
                    countDownLatch.countDown();
                }
            },String.valueOf(i)).start();
        }

        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(bankAccount.money);
    }
}
```

![image-20230403165313879](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230403165313879.png)

- **AtomicIntegerFieldUpdater**

```java
// 资源类
class BankAccount{
    String bankName = "CCB";

    //1. 必须是public volatile
    public volatile int money = 0; // 线程数

    public void add(){
        money++;
    }

    // 2. 因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须
    //    使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性
    AtomicIntegerFieldUpdater<BankAccount> fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(BankAccount.class,"money");

    //3.  不加synchronnized，保证高性能原子性，局部微创小手术
    public void transMoney(BankAccount bankAccount){
        fieldUpdater.getAndIncrement(bankAccount);
    }
}

public class AtomicIntegerFieldUpdaterDeno {
    public static void main(String[] args) {
        BankAccount bankAccount = new BankAccount();
        CountDownLatch countDownLatch = new CountDownLatch(10);

        for (int i = 1; i <= 10; i++){
            new Thread(()->{
                try {
                    for (int j = 1; j <= 1000; j++){
                        bankAccount.transMoney(bankAccount);
                    }
                }finally {
                    countDownLatch.countDown();
                }
            },String.valueOf(i)).start();
        }

        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(bankAccount.money);
    }
}
```

- AtomicReferenceFieldUpdater

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

class MyVar{
    public volatile Boolean isInit = Boolean.FALSE;

    AtomicReferenceFieldUpdater<MyVar,Boolean> referenceFieldUpdater =
            AtomicReferenceFieldUpdater.newUpdater(MyVar.class,Boolean.class,"isInit");

    public void init(MyVar myVar){
        if (referenceFieldUpdater.compareAndSet(myVar,Boolean.FALSE,Boolean.TRUE)){
            System.out.println(Thread.currentThread().getName() + "\t" + "-----start init,need 3 seconds");
            try{
                TimeUnit.SECONDS.sleep(3);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "\t" + "-----start over");
        }else {
            System.out.println(Thread.currentThread().getName() + "\t" + "-----已经有线程完成初始化操作");
        }
    }
}

/**
 * 需求:
 * 多线程开发调用一个类的初始化方法，如果违背调用初始化过
 * 要求只能初始化一次，只有一个线程操作成功。
 */

public class AtomicReferenceFieldUpdaterDemo {
    public static void main(String[] args) {
        MyVar myVar = new MyVar();

        for (int i = 1; i <= 5; i++){
            new Thread(()->{
                myVar.init(myVar);
            },String.valueOf(i)).start();
        }
    }
}
```

![image-20230404095551227](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230404095551227.png)

### 1.5 原子操作增强类原理深度解析

- **DoubleAccumulator**
- **DoubleAdder**
- **LongAccmulator**
- **LongAddr**

#### 1.5.1 阿里命题

volatile解决对线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果是多写得话，同样无法解决线程安全的问题。

```java
// 如果是count++操作，使用如下类实现:
AtomicInteger count = new AtomicInteger();
count.addAndGet(1);
// 如果是JDK8,推荐使用LongAdder对象，比AtomicLong性能更好(减少乐观锁的尝试次数)
```

1. 热点商品点赞计算器，点赞数加加统计，不要求实时精度
2. 一个很大的List，里门都是int类型，如果实现加加，说说思路。

#### 1.5.2 LongAddr和LongAccumulator简介

LongAdder当多个线程更新用于收集统计信息但不用于细粒度同步控制的目的的公共和时，此类通常优于AtomicLong。在低更新争用下，这两个类具有相似的特征。但在高争用的情况下，这一类的预期吞吐量明显更高，但代价是空间消耗更高。

![image-20230404105657147](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230404105657147.png)

- 简单API实践

  LongAdder只能用来计算加减法，且从零开始计算，LongAccumulator提供了自定义的函数操作

```java
import java.util.concurrent.atomic.LongAccumulator;
import java.util.concurrent.atomic.LongAdder;

public class LongAdderAPIDemo {
    public static void main(String[] args) {
        LongAdder longAdder = new LongAdder();

        longAdder.increment();
        longAdder.increment();
        longAdder.increment();
        System.out.println(longAdder.sum());
        LongAccumulator longAccumulator = new LongAccumulator((x,y) -> x + y,0);

        longAccumulator.accumulate(1);
        longAccumulator.accumulate(3);
        System.out.println(longAccumulator.get());
    }
}
```

- 点赞高性能实践

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.LongAccumulator;
import java.util.concurrent.atomic.LongAdder;

class ClickNumber{
    int number = 0;

    AtomicLong atomicLong = new AtomicLong();

    LongAdder longAdder = new LongAdder();

    LongAccumulator longAccumulator = new LongAccumulator((x,y) -> x + y,0);

    public synchronized void clickBySynchronized(){
        number++;
    }

    public void clickByAtomicLong(){
        atomicLong.getAndIncrement();
    }

    public void clickByLongAdder(){
        longAdder.increment();
    }

    public void clickByLongAccumulator(){
        longAccumulator.accumulate(1);
    }
}

public class LongAdderAPIDemo {
    public static final int _1w = 10000;
    public static final int threadNum = 50;
    public static void main(String[] args) {
        ClickNumber clickNumber = new ClickNumber();
        long clickTime;
        long endTime;

        CountDownLatch countDownLatch1 = new CountDownLatch(threadNum);
        CountDownLatch countDownLatch2 = new CountDownLatch(threadNum);
        CountDownLatch countDownLatch3 = new CountDownLatch(threadNum);
        CountDownLatch countDownLatch4 = new CountDownLatch(threadNum);

        clickTime = System.currentTimeMillis();

        for (int i = 1 ; i <= threadNum ; i++){
            new Thread(()->{
                try {
                    for (int j = 1; j <= 100 * _1w; j++){
                        clickNumber.clickBySynchronized();
                    }
                } finally {
                    countDownLatch1.countDown();
                }
            }
            ,String.valueOf(i)).start();
        }

        try {
            countDownLatch1.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        endTime = System.currentTimeMillis();
        System.out.println("clickBySynchronized-----costTime:  " + (endTime - clickTime) + "毫秒： " + clickNumber.number);

        clickTime = System.currentTimeMillis();
        for (int i = 1 ; i <= threadNum ; i++){
            new Thread(()->{
                try {
                    for (int j = 1; j <= 100 * _1w; j++){
                        clickNumber.clickByAtomicLong();
                    }
                } finally {
                    countDownLatch2.countDown();
                }
            }
                    ,String.valueOf(i)).start();
        }

        try {
            countDownLatch2.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        endTime = System.currentTimeMillis();
        System.out.println("clickByAtomicLong-----costTime:  " + (endTime - clickTime) + "毫秒:  " + clickNumber.atomicLong.get());

        clickTime = System.currentTimeMillis();
        for (int i = 1 ; i <= threadNum ; i++){
            new Thread(()->{
                try {
                    for (int j = 1; j <= 100 * _1w; j++){
                        clickNumber.clickByLongAdder();
                    }
                } finally {
                    countDownLatch3.countDown();
                }
            }
                    ,String.valueOf(i)).start();
        }

        try {
            countDownLatch3.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        endTime = System.currentTimeMillis();
        System.out.println("clickByLongAdder-----costTime:  " + (endTime - clickTime) + "毫秒:  " + clickNumber.longAdder.sum());

        clickTime = System.currentTimeMillis();
        for (int i = 1 ; i <= threadNum ; i++){
            new Thread(()->{
                try {
                    for (int j = 1; j <= 100 * _1w; j++){
                        clickNumber.clickByLongAccumulator();
                    }
                } finally {
                    countDownLatch4.countDown();
                }
            },String.valueOf(i)).start();
        }

        try {
            countDownLatch4.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        endTime = System.currentTimeMillis();
        System.out.println("clickByLongAccumulator-----costTime:  " + (endTime - clickTime) + "毫秒:  " + clickNumber.longAccumulator.get());

    }
}
```

![image-20230404150356838](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230404150356838.png)

## 2.LongAdder源码分析

### 2.1 LongAdder源码分析前置知识

![image-20230404150641554](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230404150641554.png)

#### 2.1.1 Striped64

![image-20230404150953102](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230404150953102.png)

![image-20230404151119719](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230404151119719.png)

**最重要的是两个cells和base变量**

![image-20230404151311504](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230404151311504.png)

#### 2.1.2 Cell

是处于striped内部的静态内部类

```java
    @sun.misc.Contended static final class Cell {
        volatile long value;
        Cell(long x) { value = x; }
        final boolean cas(long cmp, long val) {
            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
        }

        // Unsafe mechanics
        private static final sun.misc.Unsafe UNSAFE;
        private static final long valueOffset;
        static {
            try {
                UNSAFE = sun.misc.Unsafe.getUnsafe();
                Class<?> ak = Cell.class;
                valueOffset = UNSAFE.objectFieldOffset
                    (ak.getDeclaredField("value"));
            } catch (Exception e) {
                throw new Error(e);
            }
        }
    }
```

### 2.2 LongAddr高性能原因

![image-20230404152317354](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230404152317354.png)

**LongAdder的基本思路就是分散热点，将value值分散到一个Cell数组中，不同线程会命中到数组的不同槽中**，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，**冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回**。

sum()会将所有Cell数组中的value和base累加作为返回值，核心的思想就是将之前AtomicLong一个value的更新压力分散到多个value中去，从而降级更新热点。

![image-20230404152449608](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230404152449608.png)

### 2.3 源码分析（以longAdder.increment为例）

LongAdder在无竞争的情况下，跟AtomicLong一样，对同一个base进行操作，当出现竞争关系时则是采用化整为零分散热点的做法，用空间换时间，用一个数组cells，将一个value拆分近这个数组cells，多个贤臣需要同时对value机械能操作的时候，可以对进程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，在对该下标所对应的值进行自增操作。当所有线程操作完成，将数组cells的所有值和base都加起来作为最终结果。

![image-20230404153134568](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230404153134568.png)

#### 2.3.1 add(1L)

```java
/**
* 1. 如果cells表为空，尝试使用CAS更新base字段，成功则退出
* 2. 如果cells表为空，CAS更新base字段失败，出现竞争，uncontended为true，调用longAccumulate
* 3. 如果Cells表非空，但当前线程映射的槽为空，unconteded为true，调用longAccumulate
* 4. 如果Cells表非空，且目前线程映射的槽非空，CAS更新Cell的值，成功则返回，否则，uncontended设为false，调用longAccumulate
*/


public void add(long x) {
      // as是Striped64的cell是数组属性
      // b是striped64的base属性
      // v是当前线程hash到的cells种存储的值
      // m是cells的长度减1，hash时做掩码使用的
      // a时当前线程hash到的cell
      Cell[] as; long b, v; int m; Cell a;
      // 首次首线程((as = cells) != null)一定是false，此时走casBase方法，以CAS的方式更新base的值，且只有Cas失败时，才会走到if中
      // 条件1:cells不为空
      // 条件2：cas操作base失败，说明其他线程先一步修改了base正出现的竞争
      if ((as = cells) != null || !casBase(b = base, b + x)) {
          // true表示无竞争，false表示竞争激烈，多个线程hash到同一cel，可能需要扩容
            boolean uncontended = true;
          // 条件1:cells为空
          // 条件2:应该不会出现
          // 条件3：当前线程所在的cell为空，说明当前线程还没认更新过cell，应初始化一个Cell
          // 条件4：更新当前线程所在的cell失败，说明现在的竞争很激烈，多个线程hash到了同一个cell，应该扩容
            if (as == null || (m = as.length - 1) < 0 ||
               	// getProbe()方法返回的时线程中的threadlocalRandomProbe字段
                // 它是通过随机数生成的一个值，对于一个确定的线程这个值时固定的(除非刻意修改它)
                (a = as[getProbe() & m]) == null ||
                !(uncontended = a.cas(v = a.value, v + x)))
                longAccumulate(x, null, uncontended); //调用striped64中的方法处理
        }
}
```

- 变量解释
  - as表示cells引用
  - b表示获取的base值
  - v表示期待值
  - m表示cells数组的长度
  - a表示当前线程命中cell单元格
- 低并发情况下

代码只执行下面这句

```java
if ((as = cells) != null || !casBase(b = base, b + x))
```

1. 此时cells还没有做热点数据的分散，cells为空，所以as必定是null

2. caseBase(b, b + x)  完成了b + 1 取反，若返回true，则if内部就是false，直接跳出if代码块

   ```java
   // caseBase底层还是调用UNSAFE
   final boolean casBase(long cmp, long val) {
       return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);
   }
   ```

- 高并发情况下

  **caseBase就会返回false，就会调用longAccumulate，进行扩容**

#### 2.3.2 LongAccumulate

```java
final void longAccumulate(long x, LongBinaryOperator fn,
                          boolean wasUncontended) {
    // 存储线程的Probe值
    int h;
    // 如果getProbe()方法返回0，说明随机数未被初始化
    if ((h = getProbe()) == 0) {
        // 使用ThreadLocalRandom为当前线程重新计算一个hash值，强制初始化
        ThreadLocalRandom.current(); // force initialization
        // 重新获取了probe的值，hash值倍充值就好比一个全新的线程一样，所以设置了wasUncontended竞争状态设置为true
        h = getProbe();
        // 重新计算了当前线程的hash后认为此次不算是一次竞争，都未初始化，肯定还不存在竞争激烈，所以把wasUnconteded设置未true。
        wasUncontended = true;
    }
    boolean collide = false;                // True if last slot nonempty
    for (;;) {
        Cell[] as; Cell a; int n; long v;
        // CASE1 : cells已经完成被初始化
        // 此时数组不为空，并且长度大于0
        if ((as = cells) != null && (n = as.length) > 0) {
            // 进行位运算定位到槽值
            if ((a = as[(n - 1) & h]) == null) {
                // 如果发现cellsBusy是空闲状态的话，就进行cell对象的初始化
                if (cellsBusy == 0) {       // Try to attach new Cell
                    // 创建cell实例对象
                    Cell r = new Cell(x);   // Optimistically create
                    // 进行双端加锁，防止r的值再次被修改
                    if (cellsBusy == 0 && casCellsBusy()) {
                        boolean created = false;
                        try {               // Recheck under lock
                            Cell[] rs; int m, j;
                            if ((rs = cells) != null &&
                                (m = rs.length) > 0 &&
                                rs[j = (m - 1) & h] == null) {
                                // 将对应槽值进行cell赋值给对下个
                                rs[j] = r;
                                created = true;
                            }
                        } finally {
                            // 释放锁
                            cellsBusy = 0;
                        }
                        if (created)
                            break;
                        continue;           // Slot is now non-empty
                    }
                }
                collide = false;
            }
            // 如果此时竞争激烈，
            else if (!wasUncontended)       // CAS already known to fail
                wasUncontended = true;      // Continue after rehash
            // 如果成功写入
            else if (a.cas(v = a.value, ((fn == null) ? v + x :
                                         fn.applyAsLong(v, x))))
                break;
            // 如果n大于或者说cell.length > cpu的核数那么就停止扩容，没有任何意义
            else if (n >= NCPU || cells != as)
                collide = false;            // At max size or stale
            // 允许扩容
            else if (!collide)
                collide = true;
            else if (cellsBusy == 0 && casCellsBusy()) {
                try {
                    if (cells == as) {      // Expand table unless stale
                        // 创建数组
                        Cell[] rs = new Cell[n << 1];
                        // 将原来的cells数组拷到数组里面
                        for (int i = 0; i < n; ++i)
                            rs[i] = as[i];
                        cells = rs;
                    }
                } finally {
                    cellsBusy = 0;
                }
                collide = false;
                continue;                   // Retry with expanded table
            }
            // 重置当前线程的hash值
            h = advanceProbe(h);
        }
        // CASE2 : cells没有加锁并且没有初始化，则尝试对它进行加锁，并初始化cells数组
        // cellsBusy：初始化cells或者扩容cells时候需要获得锁，0代表无锁站台，1代表其他线程已经获取锁了
        // casCellsBusy(): 通过cas设置cellsBusy的值，如果成功抢到了CAS锁的话，就返回true
        // 首次传入的as为null
        else if (cellsBusy == 0 && cells == as && casCellsBusy()) {
            // 表示并没初始化
            boolean init = false;
            try {                           // Initialize table 初始化cell数组，每次都是扩2倍
                // cell == as 完成了一个双端检索，如果不进行双端检索，上个线程对应数组中的值将会被篡改
                // 可以理解为 线程A和线程B 都进行cells == as判断都等于true
                // 此时线程A拿到了cas锁，完成了cell对象的创建，然后完成了cellsBusy锁的释放，并且将它赋值为0
                // 此时线程B又来执行，发现又可以获取cas锁，，然后又会创建一遍cell
                if (cells == as) {
                    // 建立一个单元格为2的数组
                    Cell[] rs = new Cell[2];
                    // h & 1 类似于我们之前HashMap常用到的计算散列桶Index的算法，通常都是hash & （table.len - 1）,同hash同一个意思
                    rs[h & 1] = new Cell(x);
                    cells = rs;
                    init = true;
                }
            // 释放cells的锁
            } finally {
                cellsBusy = 0;
            }
            // 创建成功，退出for循环
            if (init)
                break;
        }
        // CASE3: Cells正在进行初始化，则尝试直接在基数base上进行累加操作
        // 多个线程尝试CAS修改失败的线程会走到这个分支
        // 该分支实现直接操作base基数，将值累加到base上，也即其他线程正在初始化，多个线程正在更新base的值(直接摆烂)
        else if (casBase(v = base, ((fn == null) ? v + x :
                                    fn.applyAsLong(v, x))))
            break;                          // Fall back on using base
    }
}
```

- longAccumulate()方法入参
  - long x需要增加的值，一般默认值都是1
  - LongBinaryOperator fn 默认传递的是null
  - wasUncontended是竞争，如果是false则代表有竞争。只有cells初始化以后，并且当前线程CAS竞争修改失败，才会是false；

- Striped64前置知识或者方法的定义

  ![image-20230404193136478](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230404193136478.png)

- 源码分析步骤
  - Case2
  - Case3
  - Case1

#### 2.3.3 Sum

为啥在并发情况下sum的值不精确

sum()会将所有的Cell中的value和base累加作为返回值

核心思想就是将之前的AtomicLong的一个value值的更新压力分散到多个value，从而降级而更新热点。

```
首先，最终返回的sum局部变量，初始被复制为base，而最终返回时，很可能base已经被修改。
而此时局部变量sum不会更新，造成不一致。
其次，这里对cell读取也无法保证时最后一次写入的值，所以，sum方法没有并发的情况下，可以获得正确的结果
```



## 3.总结

![image-20230405093923999](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230405093923999.png)

![image-20230405094007772](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230405094007772.png)