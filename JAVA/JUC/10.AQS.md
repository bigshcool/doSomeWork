# AQS

## 1.AQS入门级别理论知识

### 1.1 AQS是什么

![image-20230413111034362](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230413111034362.png)

### 1.2 技术解释

是用来实现锁或者其他同步器组件的公共基础部分的抽象实现，**是重量级基础框架以及整个JUC体系的基石，主要用于解决锁分配给“谁”的问题**。AQS是为了实现阻塞锁和相关同步器提供一个框架，它是依赖于先进先出的一个等待，依赖单个原子int值来表示状态(state变量)，通过占用和释放方法，改变状态值。**整体就是一个抽象的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态。**

![image-20230413112059735](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230413112059735.png)



### 1.3 AQS为什么是JUC内容中最重要的基石

#### 1.3.1 AQS相关

- ReentrantLock

```java
public class ReentrantLock implements Lock, java.io.Serializable {
    private static final long serialVersionUID = 7373984872572414699L;
    /** Synchronizer providing all implementation mechanics */
    private final Sync sync;

  	// Sync 继承 AbstractQueuedSynchronizer
    abstract static class Sync extends AbstractQueuedSynchronizer {

    }
}

```



- CountDownLatch
- ReentrantReadWriteLock
- Semaphore

![image-20230413113055940](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230413113055940.png)

#### 1.3.2. 进一步理解

- 锁，面向锁的使用者

定义了程序员和锁交互的使用层API，隐藏了实现细节，你调用即可。

- 同步器，面向锁的实现者

Java并发大神DougLee，提出统一规范并简化了锁的实现，**将其抽象出现，屏蔽了同步状态管理,同步队列的管理和维护,阻塞线程排队和通知，唤醒机制等，是一切锁和同步组件实现的——公共基础部分**

### 1.3.3 AQS能干什么

- 加锁会导致线程阻塞

有阻塞就需要排队，实现排队必然需要队列

- 源码原理

抢到资源的线程直接使用处理业务，抢不到资源的必然设计一种**排队等候机制**。抢占资源失败的线程继续去等待(类似于银行业务办理串钩都满了，暂时没有受理窗口的顾客只能去**候客区排队等候**)，但等候线程任然保留获取锁的可能并且后去锁的流程仍在继续（候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）。

既然说到**排队等候机制**，那么就一定会有某种队列形成，这样的队列是什么样的数据结构？

![image-20230413142013656](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230413142013656.png)

AQS使用一个valatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队将每条要去抢占的资源的线程封装成一个Node节点来实现锁的分配，通过CAS完成对State值得修改。

## 2. AQS源码分析理论知识储备

![image-20230413142840760](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230413142840760.png)

### 2.1 AQS的本身

![image-20230413143759512](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230413143759512.png)

- AQS的同步状态State成员变量

```java
private volatile int state
```

- AQS的双向队列

  通过自旋等待，state变量判断是否阻塞，从尾部入队，从头部出队。

### 2.2 AQS内部类Node本身

- waitStatus等待变量

用来描述等候区其他线程的等待状态。

- AQS变量注解

```java
        static final Node SHARED = new Node();    //指示节点在共享模式下等待的标记
        
        static final Node EXCLUSIVE = null;    //指示节点在独占模式下等待的标记
 
        static final int CANCELLED =  1;    //表示线程已被取消的waitStatus值
        
        static final int SIGNAL    = -1;    //表示后续线程需要取消阻塞的waitStatus值
        
        static final int CONDITION = -2;    //表示线程在条件下等待的waitStatus值
        
        static final int PROPAGATE = -3;    //表示下一个获取共享应无条件传播的waitStatus值
 
        volatile int waitStatus;    //状态字段，仅接受以上4个值和默认的0
 
        volatile Node prev;    //指向当前节点的前置节点
 
        volatile Node next;    //指向当前节点的后置节点
 
        volatile Thread thread;    //当前节点的线程
 
        Node nextWaiter;    //指向下一个条件等待节点
```

![image-20230413144657450](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230413144657450.png)

## 3. AQS源码深度讲解和分析

**Lock接口的实现类，基本都是通过聚合了一个队列同步器的子类完成线程访问控制的**

![image-20230413145144697](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230413145144697.png)

### 3.1 从Lock接口了解AQS

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo {
    public static void main(String[] args) {
        Lock lock = new ReentrantLock();
        
        lock.lock();
        try {
            
        }finally {
            lock.unlock();
        }
    }
}
```

- 简单代码如上,总体而言Lock的接口由ReentrantLcok实现，然后在ReentrantLock重载的方法里面lock方法，其实调用的是sync的lock方法.

```java
public void lock() {
    sync.lock();
}
```

- 而sync变量的赋值，在创建ReentrantLock()的时候，完成非公平锁和公平锁的赋值.

```java
public ReentrantLock() {
   sync = new NonfairSync();
}

public ReentrantLock(boolean fair) {
   sync = fair ? new FairSync() : new NonfairSync();
}
```

- 而FiarSync和NonfairSync继承于Sync，Sync继承于AbstractQueuedSynchronizer，实现了AQS

```java
abstract static class Sync extends AbstractQueuedSynchronizer {

}

/**
 * Sync object for non-fair locks
 */
static final class NonfairSync extends Sync {

}

/**
 * Sync object for fair locks
 */
static final class FairSync extends Sync {

}
```

- 查看NonFairSync中的lock方法到底发生了什么

```java
final void lock() {
      // 期望值是0，修改值是1，还是和CAS非常相似的
      if (compareAndSetState(0, 1))
          // 如果获取锁资源成功了，那么就设置独占资源执行当前线程
          setExclusiveOwnerThread(Thread.currentThread());
      else
          // 没有获取到锁，则调用acquire方法
          acquire(1);
}
```

- 假如此时是公平锁，并且没有抢到锁志愿，则会调用acquire(1)方法，然后会执行tryAcquire方法

```java
public final void acquire(int arg) {
    // 此时会调用父类的tryAcquire方法，但是你查看父类的tryAcquire方法，你会惊奇的发现，里面只是做了保底的完成
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

- AbstractQueuedSynchronizer

```java
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}
```

- 公平锁的tryAcquire方法

```java
protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                // 非公平方法就是多了一个hasQueuedPredecessors()方法
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
```

![image-20230413155749178](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230413155749178.png)

​	

公平锁和非公平锁唯一的区别就是调用了hasQueuedPredecessors，hasQueuePredecessors是公平锁所示判断等待队列总是否存在有效节点的方法。hasQueuedPredecessors()中判断了是否需要排队，导致了公平锁和非公平锁的差异如下:

**公平锁:**公平锁讲究先来先到，线程在获取锁的时候，如果这个锁定的等待队列已经由线程在等待了，那么当前线程就会进入到等待队列中。

**非公平锁:**不管是否有等待队列，如果可以获取锁，则立刻占有锁，也就是说队列的第一排线程苏醒后，不一定就是排头的这个线程获得了锁，他还是需要需要参加锁的竞争的，后来的线程可能**不讲武德**插队夺锁了。

- hasQueuedPredecessors方法

```java
public final boolean hasQueuedPredecessors() {
    // The correctness of this depends on head being initialized
    // before tail and on head.next being accurate if the current
    // thread is first in queue.
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
        return h != t &&
            ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

### 3.2 