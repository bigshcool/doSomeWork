## 乐观锁

认为自己在使用数据不会有其他的线程修改数据或者资源，所以不会添加锁。

在Java中采用无锁编程来实现，知识更新数据的时候去判断，之前没有别的线程更新了这个数据。



如果这个数据没有被更新，当前线程将自己修改的数据写入。

如果这个数据被其他的线程更新，则根据不同的额实现方式执行不同的操作，比如放弃修改，重试抢锁等等。



判断规则

1.版本号机制Version

2.最常采用的是CAS算法，JAVA原子类中的递增操作通过CAS自旋操作完成。

## 悲观锁

认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加索，确保数据不会被其他的线程来修改。

适合写操作多的场景，先加索可以保证写操作时数据正确。显性的锁定以后再操作同步资源。



## 八锁案例

题目: 谈谈你对多线程的理解，8锁案例说明

口诀:线程 	操作:资源类

```java
class Phone{
    public synchronized void sendEmail(){
        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println("发邮件了");
    }

    public synchronized void sendEMS(){
        System.out.println("发短信了");
    }

    public void hello(){
        System.out.println("hello");
    }
}
```

8锁案例说明:

1. 标准访问有ab两个线程，请问先打邮件还是短信
2. sendEmail方法中加入停顿5秒，请问是先打印邮件还是短信
3. 添加一个普通的hello方法，请问是先打印邮件还是hello
4. 有两部手机，请问是先打印邮件还是先打印短信
5. 有两个静态同步方法，有1部手机，请问是先打印邮件还是短信
6. 有两个静态同步方法，有2部手机，请问是先打印邮件还是短信
7. 有一个静态同步方法，有一个普通同步方法，有一部手机
8. 有一个静态同步方法，有一个普通同步方法，有两部手机



## 公平锁和非公平锁

```java
import java.util.concurrent.locks.ReentrantLock;

class Ticket{
    private int number = 50;
    // true 表示公平锁
    // 默认表示非公平锁
    ReentrantLock lock =  new ReentrantLock(true);

    public void sale(){
        lock.lock();
        try {
            if (number > 0){
                System.out.println(Thread.currentThread().getName() + " 卖出第 :\t " + (number--));
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}

public class SaleTicketDemo {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        new Thread(() ->{
            for (int i = 0; i < 55 ; i++){
                ticket.sale();
            }
        },"aa").start();

        new Thread(() ->{
            for (int i = 0; i < 55 ; i++){
                ticket.sale();
            }
        },"bb").start();

        new Thread(() ->{
            for (int i = 0; i < 55 ; i++){
                ticket.sale();
            }
        },"cc").start();
    }
}
```

### 公平锁

只多个线程按照申请的锁驯熟来获取锁，这里类似于排队买票，先来的人先买后来的人在队尾拍着，这是公平的Lock lock = new ReentrantLock（ture）表示公平锁，先来先得

### 非公平锁

是指多个线程获取锁的顺序并不是按照申请锁的循序，有可能后申请的线程要比先申请线程优先获取锁，并在高并发环境下，有可能造成优先级翻转或饥饿的状态



#### 为什么会有公平锁/非公平锁？为什么默认非公平锁

- 恢复挂起的线程到真正的锁的获取还有时间差，从开发人员来看这个时间微乎其微，但是从CPU角度来看，这个时间差存在的还是很明显。所以非公平锁能更充分的利用CPU时间片，尽量减少CPU空闲状态时间
- 使用多线程很重要的考量就是线程切换的开销，当采用非公平锁时，当1个线程请求所获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就非常大，所以就减少了进程的开销

#### 什么时候使用公平？什么时候使用非公平

如果是为了更好的吞吐量，很显然非公平是比较合适，因为节省很多线程切换的时间，吞吐量就上去了，否则就使用公平锁，大家公平使用。



## 可重入锁

可重入锁又名递归锁在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象是一个对象)，不会因为之前已经获取过还没释放而阻塞。

如果是1个具体有synchronized修饰的递归调用方法，程序第二次进入被自己阻塞于就搞笑了。

所以Java中**ReentrantLock和synchronized都是可重入锁**，可重入锁的一个有点就是可一定程度避免死锁。

![image-20230325205642512](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230325205642512.png)

一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入，自己可以获取自己的内部锁。

### 隐式锁(synchronized)

指的是可重复递归调用的锁，在外层使用锁以后，在内层任然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。简单的来说就是:在一个synchronized修饰的方法或者代码块的内部调用本类的其他synchronized修饰的方法和代码块时，是永远可以得到锁的。

- 同步代码块演示

```java
public class ReEntryLockDemo {
    public static void main(String[] args) {
        final Object o = new Object();
        new Thread(()->{
            synchronized (o){
                System.out.println(Thread.currentThread().getName() + "\t----外层调用");
                synchronized (o){
                    System.out.println(Thread.currentThread().getName() + "\t----中层调用");
                    synchronized (o){
                        System.out.println(Thread.currentThread().getName() + "\t----内层调用");
                    }
                }
            }
        },"t1").start();
    }
}
```

- 同步方法演示

```java
public class ReEntryLockDemo {
    public static void main(String[] args) {
        ReEntryLockDemo reEntryLockDemo = new ReEntryLockDemo();
        reEntryLockDemo.m1();
    }

    public synchronized void m1(){
        System.out.println(Thread.currentThread().getName() + "\t------ come in");
        m2();
        System.out.println(Thread.currentThread().getName() + "\t------ end");
    }

    private synchronized void m2() {
        System.out.println("m2");
        m3();
    }

    private synchronized void m3() {
        System.out.println("m3");
    }
}
```

 #### synchronized的重入实现机制

首先我们要知道所有Object都能成为锁对象，而Object锁机制是由cpp实现的，objectMonitor.java -> objectMonitor.cpp->objectMonitor.hpp，在objectMonitor含有几个较为重要的字段。每个锁对象都拥有一个**锁计数器和一个持有该锁的线程指针**，当执行monitorenter时，如果目标锁对象的计数器为0，则说明他没有被其他的线程持有，java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1.

在目标锁对象的计数器不为0的情况下，如果锁对象的持有线程是当前线程，那么java虚拟机可以将其计数器加1，否则则需要等待，直至持有线程释放该锁。

当执行monitorexit时，java虚拟机则需要将锁对象的计数器减1.计数器为0代表锁已经释放(在同步代码块中，如果反向编译的化其实会出现monitorexit两次，但是其实不是表明退出两次，而是说有异常的时候会进行退出处理)。

### 显式锁（ReentrantLock）





## 死锁

死锁是指两个或者两个以上的线程在执行过程中，因争夺资源而造成一种资源等待的现象，如果无外力干涉那他们都无法推进下去，如果系统资源充足，请求的资源都能够得到满足，死锁出现的可能性就能很低，否则就会争夺有限的资源而陷入死锁。

```java
public class DeadLockDemo {
    public static void main(String[] args) {
        final Object o1 = new Object();
        final Object o2 = new Object();

        new Thread(() ->{
            synchronized (o1){
                System.out.println(Thread.currentThread().getName()+"拿到锁1");
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                synchronized (o2){
                    System.out.println(Thread.currentThread().getName()+"拿到锁2");
                }
            }
        },"thead1").start();

        new Thread(() ->{
            synchronized (o2){
                System.out.println(Thread.currentThread().getName()+"拿到锁2");
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                synchronized (o1){
                    System.out.println(Thread.currentThread().getName()+"拿到锁1");
                }
            }
        },"thead2").start();
    }
}
```

### 检测死锁方法

- 命令行

![image-20230325232549483](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230325232549483.png)

​	查出你所怀疑进程的pid

​	![image-20230325232636894](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230325232636894.png)

​	打印栈信息

- 图形化界面(jconsole)

  ![image-20230325232740506](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230325232740506.png)



![image-20230325232822488](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230325232822488.png)