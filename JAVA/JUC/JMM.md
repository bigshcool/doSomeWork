# JMM（JAVA内存模型）

- 什么是JMM

  在JVM规范中试图定义一种Java内存模型(简称 JMM)来**屏蔽各种硬件和操作系统的内存访问差异**。以实现让Java程序在各种平台下能达到的一致性内存访问效果。

  JMM本身是一种抽象的概念并不真实的存在它仅仅是描述的是一组约定或者规范，通过这组规范定义了程序中（尤其是多线程）各个变量的读写方式并决定一个线程对共享变量的写入何时以及如何变成另一个线程可见，关键技术点都是围绕多线程的**原子性、可见性和有序性。**JMM的关键技术点都是围绕多线程的**原子性、可见性和有序性展开的。**

  - 能干嘛
    - 通过JMM来实现线程和主内存之间的抽象关系
    - 屏蔽各个硬件平台和操作系统的内存访问差异以实现让JAVA程序在各种平台下都能达到一致的内存访问效果。

- JMM三大特性

  - 可见性

  ![image-20230327163211222](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230327163211222.png)

  ​		**是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更**，JMM指定了所有的变量都存储到主内存中。系统主内存共享变量数据修改被写入的时候是不确定的，多线程并发下很可能出现“脏读”，**所以每个线程都有自己的工作内存**，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取，赋值等)都必需在线程自己的工作内存中进行，而不能够直接读写内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存完成。

  | 线程脏读                                                     |
  | ------------------------------------------------------------ |
  | 主内存中变量x,初始值为0                                      |
  | 线程A要将x加1，先将x=0拷贝到自己的私有内存中，然后更新x的值  |
  | 线程A将更新后的x值回刷主内存的时间不是固定的                 |
  | 刚好在线程A没有回刷x到内存时，线程B同样从主内存读取x，此时为0，线程A一样的操作，最后期盼的x = 2就会变成x = 1 |

  - 原子性

    指一个操作是不可打断的，即多线程线程中，操作不能被其他线程干扰。

  - 有序性

    对于 一个线程的执行代码，我们总习惯性认为代码的执行总是从上到下，有序执行。但是为了提升性能，编译器和处理器通常会指令通常会指令进行重拍。JAVA规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序执行的结果灯箱，那么指定的顺序可以与代码顺序不一致，此过程叫做指令的重排序。

    指令重拍可以保证串行语义一致，但是没有义务保证多线程的语义一致，简单说。

    两行以上不相干的代码在执行的时候有可能执行的不是第一条，**不见得从上到下顺序执行，执行顺序会被优化。**

    从源码到最终执行示例图:

    ![image-20230327174017228](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230327174017228.png)

    单线程环境里面确保程序最终执行的结果和代码顺序执行的结果一致。

