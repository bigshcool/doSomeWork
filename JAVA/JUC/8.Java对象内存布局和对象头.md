# Java对象内存布局和对象头

```java
public class ObjectHeadDemo {
    public static void main(String[] args) {
        Object o = new Object(); // ? new 一个对象，占内存多少

        System.out.println(o.hashCode()); // 这个hashcode记录在对象的什么地方?

        synchronized (o){   // 同步锁的标记
        }

        System.gc(); //手动收集垃圾，从新生代 到 老生代
    }
}
```

这些问题都可以从对象内存布局中找到答案。

## 1. 对象内存布局

![image-20230407221900096](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230407221900096.png)

对象内部结构分别是:对象头，数据实例，对齐填充(**保证8个字节的倍数**)。

### 1.1 对象头

- 对象标记Mark Word

  ![image-20230407223103383](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230407223103383.png)

  ![image-20230407223236232](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230407223236232.png)

  在64位系统中，MarkWord占了8个字节，类型指针占8个字节，一共是16个字节。

  ![image-20230407232533070](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230407232533070.png)

  ![image-20230408084041068](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408084041068.png)

  总体而言，对象布局,GC回收和锁升级就是对象标记MarkWord里面的标志位的变化。

- 类型指针Class pointer(又叫)：类元信息存储的是指向该对象类元数据的首地址。

  ![image-20230407233007803](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230407233007803.png)

  对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例对象。

- 对象头的大小

  ```java
  class Customer{ // 只有一个对象头的实例对象
  
  }
  ```

  在64位系统中，Mark Word占了8个字节，类型指针占了8个字节，一共是16个字节。

### 1.2 实例数据

存放类的属性(Field)数据信息，包括父类的属性信息。

### 1.3 对齐填充

虚拟机要求对象的起始地址一定要是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐这部分内存按照8字节进行补充对齐。



## 2. 深入了解Object o = new Object()

### 2.1 引入JOL

```xml
<dependencies>
    <dependency>
        <groupId>org.openjdk.jol</groupId>
        <artifactId>jol-core</artifactId>
        <version>0.9</version>
    </dependency>
</dependencies>
```

### 2.2 打印JVM细节

![image-20230408085107327](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408085107327.png)

### 2.3 打印对象头信息

```java
import org.openjdk.jol.info.ClassLayout;

public class JOLDemo {
    public static void main(String[] args) {
        // 打印object对象的对象头
        Object o = new Object();
        System.out.println(ClassLayout.parseInstance(o).toPrintable());

        // 打印普通类的对象信息
        Customer c = new Customer();
        System.out.println(ClassLayout.parseInstance(c).toPrintable());

        // 打印普通类的对象信息
        Car car = new Car();
        System.out.println(ClassLayout.parseInstance(car    ).toPrintable());
    }
}

// 只有对象头，没有什么实际数据
class Customer{

}
// 拥有两个实例数据
class Car{
    int id;
    boolean flag = false;
}
```

输出结果如下:会发现object也是没有任何实例数据的和Customer对象输出的结果一样，只包含8位的**对象标记**和**4位的类型指针**，但是之前说类型指针是需要8位的，但是此时只有4位作为类型指针，这个后面在讲，然后我们看对齐位数必须是8的整数倍，所以要进行填充，于是就会有损失，在space Losses中可以看见，而对于有实例数据的对象呢，实例数据也占据一部分空间。

```java
ava.lang.Object object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           e5 01 00 20 (11100101 00000001 00000000 00100000) (536871397)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

learn.blili.juc.Customer object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           d4 cb 00 20 (11010100 11001011 00000000 00100000) (536923092)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

learn.blili.juc.Car object internals:
 OFFSET  SIZE      TYPE DESCRIPTION                               VALUE
      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4           (object header)                           12 cc 00 20 (00010010 11001100 00000000 00100000) (536923154)
     12     4       int Car.id                                    0
     16     1   boolean Car.flag                                  false
     17     7           (loss due to the next object alignment)
Instance size: 24 bytes
Space losses: 0 bytes internal + 7 bytes external = 7 bytes total
```

### 2.4 类型指针压缩问题

- 会发现本应该使用8个字节的类型指针只使用了4个字节

![image-20230408091459598](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408091459598.png)

- 打印JVM参数发现，JVM参数中用压缩类型指针，默认是开启的。

![image-20230408092232133](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408092232133.png)

- 手动关闭看看(**一般不用调整，因为这样性能更好**)

  - 步骤1:-XX:-UseCompressedClassPointers

    ![image-20230408092803949](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408092803949.png)

  - 步骤二:输出结果，发现类型指针变成了8位

    ![image-20230408093018806](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408093018806.png)