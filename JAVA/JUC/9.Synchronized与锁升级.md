# Synchronized与锁升级

## 1 synchronized优化背景

高并发时，同步调用应该去考量锁的性能消耗。能用无锁数据结果，就不要用锁。能锁区块，就不要锁整个方法；能用对象锁，就不要用类锁。**尽可能使加锁的代码块尽可能的小，避免在所代码块中调用RPC方法。**

用所能够实现数据的安全性，但是会带来性能的下降。无锁能够基于线程并行提升程序性能，但是会带来性能下降。于是为了在锁的性能与安全性中取得平衡。

![image-20230408095801171](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408095801171.png)

由对象头中的Mark Word根据锁标志位的不同而被复用以及锁升级策略。

![image-20230408100212479](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408100212479.png)

## 2 synchronized锁复习与补充

### 2.1 Synchronized重量级锁

在java5以前，只有Synchronized整个操作级别是重量级的操作，**而重量级锁，假如锁的竞争比较激烈的话，性能下降，性能下降主要提现在用户态和内核态切换。**

![image-20230408100833950](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408100833950.png)

### 2.2 对象是天生的管程(Monitor)

![image-20230408101348800](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408101348800.png)

### 2.3 Monitor(监视器锁)

JVM的同步锁是基于进入和退出管程的(Moniter)对象实现的，每个对象都会有一个Monitor，Monitor可以和对象一起创建，销毁。Mintor是由ObjectMonitor实现的，而ObjectMonitor是由C++ObjectMonitor.hpp文件实现的，如下所示:

![image-20230408103420514](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408103420514.png)

### 2.4 Mutex Lock(互斥系统变量)

Monitor是实现jvm底层实现，底层代码是C++。本质是依赖于底层操作系统的Mutex Lock，操作系统实现线程之间的切换需要从用户态到内核态的切换，状态转换需要耗费很多的处理器时间成本，所以synchronized是Java语言中的一个重量级操作。

###  2.5 Monitor与Java对象是如何关联的

1. 如果是一个java对象被某个线程锁住，则该对象的Mark Word字段中Lock Word指向的Monitor的起始地址。
2. Monitor的Owner变量字段会存放游泳相关对象锁的线程ID

### 2.6 重量级锁小总结

![image-20230408105449161](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408105449161.png)

![image-20230408105644890](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408105644890.png)

Java6以后，为了减少获取锁和释放锁所带来的性能开销，引入了轻量级锁，意向锁，需要有个逐步升级的过程，别一开始就直接到重量级锁。

## 3.锁升级流程

### 3.1 多线程访问情况

- 只有一个线程来访问，有且只有only one
- 有多个线程(2个线程A,B来交替访问)
- 竞争激烈，更多个线程来访问

### 3.2 锁升级内存依据

synchronized用的锁是存在Java对象头中的Mark Word中，锁升级的功能主要依赖于锁标志位和释放偏向锁标志位。

![image-20230408111035884](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408111035884.png)

- 偏向锁: MarkWord存储的是**偏向的线程ID**;
- 轻量锁:MarkWord存储的是指向**线程栈**中的Lock Record；
- 重量锁:MarkWord存储的是指向**堆中的**monitor对象的指针;

### 3.3 无锁

![image-20230408214427857](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408214427857.png)

小端模式进行数据的存储，但是此时没有看到hashCode，因为你会发现中间都是0，这肯定是不合理的，**但是注意看图，这里是hashCode是需要调用hashCode函数才可以。**

![image-20230408215012370](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408215012370.png)

大部分情况下对象的hashCode都用不到，所以就没有必要浪费时间在创建的时候给你算一遍，需要的时候进行调用，然后完成对象头的赋值。

```java
import org.openjdk.jol.info.ClassLayout;

public class SynchronizedUpDemo {
    public static void main(String[] args) {
        Object o = new Object();

        System.out.println("10 进制   " + o.hashCode());

        System.out.println("16 进制   " + Integer.toHexString(o.hashCode()));

        System.out.println("2 进制   " + Integer.toBinaryString(o.hashCode()));

        System.out.println(ClassLayout.parseInstance(o).toPrintable());
    }
}
```

注意小端模式，是字节反序，但是字节内部是顺序的，蓝色的是锁标志，红色的是hashcode地址。

![image-20230408221259793](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230408221259793.png)

### 3.4 偏向锁

当线程A第一次竞争到锁时，通过操作修改MarkWord中的偏向线程ID，偏向模式。如果不存在其他线程的竞争，那么持有偏向锁的线程将永远不需要进行同步。

#### 3.4.1 主要作用

当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获取锁。**首先要知道的是，线程的调度是在内核态进行的，假设一个场景，此时只有一个线程，然后它的时间片使用完了，然后此线程又同时也在不断访问资源类，我要进行用户态到内核态的切换，来判断是否调度这个线程，这个是需要开销的**

举个生活的例子，就是你只去一家餐厅，只点一样的菜品，点了20天服务员就知道了，你来的时候需要什么菜品，而不是每次都要你报一遍你的菜品。

#### 3.4.2 代码

```java
class Ticket{
    private int number = 50;

    Object object = new Object();

    public void sale(){
        synchronized (object){
            if (number > 0){
                System.out.println(Thread.currentThread().getName() + "卖出第: \t" + (number--) + "\t 还剩下" + number);
            }
        }
    }
}

public class SynchronizedUpDemo1 {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();

        new Thread(()->{
            for (int i = 0;i < 55;i++){
                ticket.sale();
            }
        },"A").start();

        new Thread(()->{
            for (int i = 0;i < 55;i++){
                ticket.sale();
            }
        },"B").start();

        new Thread(()->{
            for (int i = 0;i < 55;i++){
                ticket.sale();
            }
        },"C").start();
    }
}
```

**我会发现A线程释放了锁对象资源后，后面其实都是B争抢到了线程，甚至C都没有机会。**

```java
A卖出第: 	50	 还剩下49
A卖出第: 	49	 还剩下48
A卖出第: 	48	 还剩下47
B卖出第: 	47	 还剩下46
B卖出第: 	46	 还剩下45
B卖出第: 	45	 还剩下44
B卖出第: 	44	 还剩下43
B卖出第: 	43	 还剩下42
B卖出第: 	42	 还剩下41
B卖出第: 	41	 还剩下40
B卖出第: 	40	 还剩下39
B卖出第: 	39	 还剩下38
B卖出第: 	38	 还剩下37
B卖出第: 	37	 还剩下36
B卖出第: 	36	 还剩下35
B卖出第: 	35	 还剩下34
B卖出第: 	34	 还剩下33
B卖出第: 	33	 还剩下32
B卖出第: 	32	 还剩下31
B卖出第: 	31	 还剩下30
B卖出第: 	30	 还剩下29
B卖出第: 	29	 还剩下28
B卖出第: 	28	 还剩下27
B卖出第: 	27	 还剩下26
B卖出第: 	26	 还剩下25
B卖出第: 	25	 还剩下24
B卖出第: 	24	 还剩下23
B卖出第: 	23	 还剩下22
B卖出第: 	22	 还剩下21
B卖出第: 	21	 还剩下20
B卖出第: 	20	 还剩下19
B卖出第: 	19	 还剩下18
B卖出第: 	18	 还剩下17
B卖出第: 	17	 还剩下16
B卖出第: 	16	 还剩下15
B卖出第: 	15	 还剩下14
B卖出第: 	14	 还剩下13
B卖出第: 	13	 还剩下12
B卖出第: 	12	 还剩下11
B卖出第: 	11	 还剩下10
B卖出第: 	10	 还剩下9
B卖出第: 	9	 还剩下8
B卖出第: 	8	 还剩下7
B卖出第: 	7	 还剩下6
B卖出第: 	6	 还剩下5
B卖出第: 	5	 还剩下4
B卖出第: 	4	 还剩下3
B卖出第: 	3	 还剩下2
B卖出第: 	2	 还剩下1
B卖出第: 	1	 还剩下0

Process finished with exit code 0
```

多线程的情况下，锁不紧不存在多线程竞争，还存在锁由一个线程多次获得的情况，偏向锁就是在这种情况下出现的，它的出现是为了解决**只有一个线程执行同步时提高性能。**偏向锁会偏向第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程永远不需要触发同步。也即偏向锁在没有资源竞争的情况下消除了同步语句，懒得连CAS操作都不做了，直接提高了程序的性能。

#### 3.4.3 理论落地

​	 在实际应用运行过程中发现，“锁总是一个线程持有，很少发生竞争”，**也就是说锁总被第一个占用他的线程所拥有，这个线程就是锁的偏向线程**。

​	 那么只需要在锁的第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁(后续这个线程进入和退出这段加了同步锁的代码块是，**不需要再次加锁和释放锁**。而是会直接去检查锁定额MarkWord里面是不是存放自己的线程ID).

- 如果相等，表示偏向锁是偏向当前线程的，就不需要再次尝试获得锁了，知道竞争发生才释放锁。以后每次同步都要检查偏向线程ID和当前ID是否一致，如果一致则直接进入同步。无需每次都要加锁解锁去CAS更新对象头。**如果自始自终使用锁的线程只有一个**，很明显偏向锁几乎没有额外开销，性能较高。

- 如果不等，**表示发生了竞争，锁已经不是总是偏向同一个线程了**，这个时候会尝试使用CAS来替换MarkWord里面的线程ID为新线程的ID;

  - 竞争成功，表示之前的线程不存在了，MarkWord里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁。
  - 竞争失败，把这时候可能需要升级为轻量级的锁，才能保持线程间公平竞争锁。

  **注意，偏向锁只有遇到其他线程尝试竞争偏向锁的时候，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的**

#### 3.4.4 Account举例

![image-20230409101953953](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230409101953953.png)

**结论:JVM不用和操作系统协商上述过程就是偏向锁，它只需要记录下线程ID就表示自己获得了当前锁，不用操作系统接入，上述就是偏向锁，在没有其他的线程竞争的时候，一直偏向当前线程，当前线程可以一直执行。**

#### 3.4.5 锁升级之参数启动偏向锁

- 打印JAVA虚拟机偏向锁参数(windows)

  ```java
  java -XX:+PrintFlagsInitial | findstr BiasedLock*
  ```

- 参数细节

  ```java
   intx BiasedLockingBulkRebiasThreshold          = 20                                  {product}
   intx BiasedLockingBulkRevokeThreshold          = 40                                  {product}
   intx BiasedLockingDecayTime                    = 25000                               {product}  
   intx BiasedLockingStartupDelay                 = 4000                                {product}  // 偏向锁启动有延迟 4s
   bool TraceBiasedLocking                        = false                               {product}
   bool UseBiasedLocking                          = true                                {product}  //默认在产品级应用是默认打开
  ```

- 通过修改Java虚拟机参数实现偏向锁的展示

  ```java
  class Ticket{
      private int number = 50;
  
      Object object = new Object();
  
      public void sale(){
          synchronized (object){
              System.out.println(ClassLayout.parseInstance(object).toPrintable());
          }
      }
  }
  
  public class SynchronizedUpDemo1 {
      public static void main(String[] args) {
          Ticket ticket = new Ticket();
  
          new Thread(()->{
              for (int i = 0;i < 55;i++){
                  ticket.sale();
              }
          },"A").start();
      }
  }
  ```

  **提问：此时我已经是单个线程完成对锁重复的获取，是否对象头的偏向锁和锁的标志位一定是101呢？**

  ```java
  java.lang.Object object internals:
   OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
        0     4        (object header)                           30 f1 af 88 (00110000 11110001 10101111 10001000) (-2001735376)
        4     4        (object header)                           24 00 00 00 (00100100 00000000 00000000 00000000) (36)
        8     4        (object header)                           e5 01 00 20 (11100101 00000001 00000000 00100000) (536871397)
       12     4        (loss due to the next object alignment)
  Instance size: 16 bytes
  Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
  ```

  **此时的结果是否定的，因为偏向锁的启动是需要延时的，此时没有经过4s，所以偏向锁无法开启。为了演示效果，需要将java虚拟机参数修改为:**

  ```java
  -XX:BiasedLockingStartupDelay=0
  ```

  **锁的资源对象头**

  ![image-20230409105241854](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230409105241854.png)

- 通过程序休眠展示偏向锁

  ```java
  import org.openjdk.jol.info.ClassLayout;
  
  import java.util.concurrent.TimeUnit;
  
  class Ticket{
      private int number = 50;
  
      Object object = new Object();
  
      public void sale(){
          synchronized (object){
              System.out.println(ClassLayout.parseInstance(object).toPrintable());
          }
      }
  }
  
  public class SynchronizedUpDemo1 {
      public static void main(String[] args) {
          try {
              TimeUnit.SECONDS.sleep(6);
          } catch (InterruptedException e) {
              throw new RuntimeException(e);
          }
          // 注意此时的创建共享资源一定要在休眠的后面
          Ticket ticket = new Ticket();
  
          new Thread(()->{
              for (int i = 0;i < 2;i++){
                  ticket.sale();
              }
          },"A").start();
      }
  }
  ```

  ![image-20230409105659393](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230409105659393.png)

  #### 3.4.5 偏向锁开启时，锁没有被线程使用和被线程使用时展示。

  ```java
  import org.openjdk.jol.info.ClassLayout;
  import java.util.concurrent.TimeUnit;
  
  class Ticket{
      private int number = 50;
  
      Object object = new Object();
  
      public void sale(){
          synchronized (object){
              System.out.println(ClassLayout.parseInstance(object).toPrintable());
          }
      }
  }
  
  public class SynchronizedUpDemo1 {
      public static void main(String[] args) {
          try {
              TimeUnit.SECONDS.sleep(6);
          } catch (InterruptedException e) {
              throw new RuntimeException(e);
          }
          // 此时偏向锁开启了锁部分的标志位，但是偏向锁还没被启用，所以地址部分的话就是0
          Object o = new Object();
          String s = ClassLayout.parseInstance(o).toPrintable();
          System.out.println(s);
          System.out.println("===================");
          new Thread(()->{
              // 此时偏向锁锁开始使用。
              synchronized (o){
                  Thread thread = Thread.currentThread();
                  System.out.println(ClassLayout.parseInstance(o).toPrintable());
                  System.out.println();
              }
          },"A").start();
      }
  }
  ```

  ![image-20230409111838357](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230409111838357.png)

  

#### 3.4.6 偏向锁的撤销

偏向锁使用一种等到**竞争出现才释放锁的机制**，当只有其他线程竞争时，持有偏向锁的原来线程才会被撤销。

**撤销需要等待全局安全点(该时间点没有字节码正在执行)，同时检查偏向锁的线程是否还在执行。**

- 第一个线程正在执行synchronized方法(**处于同步块**)，它还没有执行完，其他线程来争夺，该偏向锁会被取消掉并且出现**锁升级**。此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。
- 第一个线程执行完synchronized方法(**退出同步块**)，则将对象头设置成无锁状态并且撤销偏向锁，重新偏向。

![image-20230410103011882](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230410103011882.png)

#### 3.4.7 Java15以后逐渐取消偏向锁

### 3.5 轻量级锁

**轻量级锁：多线程竞争，但是任意时刻最多只有一个线程竞争，即不存在太激烈的锁竞争情况，也就没有线程阻塞，什么要锁的竞争不是很激烈的情况呢，就是获取锁的冲突时间极短，比如就是A线程执行完了，B线程执行，B线程执行完了C执行，本质就是CAS自旋锁，但是线程如果自旋达到了一定的次数，那么就要升级到重量级锁。**

#### 3.5.1 轻量级锁的获取

![image-20230410104331224](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230410104331224.png)

![image-20230410104724271](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230410104724271.png)

![image-20230410105052702](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230410105052702.png)

#### 3.5.2 轻量级锁代码实例

**如果关闭偏向锁，就可以直接进入轻量级锁**

```java
-XX:-UseBiasedLocking
```

![image-20230410105710315](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230410105710315.png)

#### 3.5.3 自旋次数

- Java6之前(了解一下)

  - 默认启动，默认情况下自选的次数是10。
  - 自旋线程数超过CPU核数的一半

- Java6以后

  使用自适应自旋锁的，线程如果自旋成功了，那么下次自旋的最大次数会增加，因为JVM认为既然上次成功了，那么这次也很大概率会成功。反之，线程如果一直没有抢到线程，就会把下次自旋次数减小，避免CPU空转。

#### 3.5.4 轻量锁和偏向锁的区别

- 争夺轻量锁失败时，自旋尝试抢占锁
- 轻量锁每次退出同步块的时候都需要释放锁，而偏向锁是在竞争发生时才释放锁。

### 3.6 重量级锁

#### 3.6.1 重量级锁原理

Java中Synchronized的重量级锁，是基于进入和退出Monitor对象实现的。在编译时会将同步块的开始位置插入monior enter指令，在结束位置插入monitror exit指令。

当线程执行到monitor enter指令时，会尝试获取对象对应的Monitor所有权，如果获取到了，即获取到了锁，会在Monitor的owner中存放当前线程的id，这样他处于锁定锁定状态，除非退出同步块，否则其他线程无法获取到这个Monitor。

### 3.7 总结与扩展

#### 3.7.1 HashCode

锁升级为轻量级后者重量级锁后，Mark Word中保存的分别是**线程栈帧里面的锁记录指针和重量级锁指针，已经没有位置保存哈希码**，我们要了解锁的指向：

- 偏向锁:MarkWord存储的是偏向的线程ID
- 轻量锁：MarkWord存储的是指向线程栈中Lock Record的指针
- 重量锁：MarkWord存储的是指向堆中的monitor对象的指针。

![image-20230410223155764](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230410223155764.png)

- 无锁状态下,Mark Word中可以存储对象的identity hash code。当对象的hashCode()方法第一次被调用时，JVM会生成对应的identity hash code值并且将该值存储到Mark Word中。
- 对于偏向锁，在线程获取偏向锁时，会用Thread ID 和 epoch值覆盖identity hash code所在位置。如果一个对象的hashCode()方法已经被调用过一次后，这个对象不能被设置偏向锁。因为如果可以的话，那Mark Word中的identity hash code必然会被偏向线程ID覆盖，这就会造成同一个对象前后两次调用hashCode()得到的结果不一致。

- 升级为轻量级锁的时候，JVM会在当前线程的栈帧中创建一个锁记录(Lock Record)空间，用于存储对象的Mark Word拷贝，该拷贝中可以包含identity hash code，所以**轻量级锁可以和identity hash code共存**，哈希码和GC年龄自然保存于此，释放锁后会将这些信息写回对象头。
- 升级到重量级锁后，Mark Word保存的重量级锁指针，代表重量级锁的ObjectMonitor有字段记录非加锁状态下的Mark Word，锁释放后也会将信息写回对象头。



#### 3.7.2 锁升级

![image-20230410225336085](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230410225336085.png)

- **偏向锁**：适用于单线程情况，不存在锁竞争的时候进入同步方法或者同步代码块则使用偏向锁。
- **轻量级锁**：适用于竞争不激烈的情况，存在竞争时升级为轻量级锁，轻量级锁采用的时自旋锁，如果同步方法/代码块执行时间很短的话，次啊用轻量级锁虽然会占用CPU资源，但是相对使用重量级锁还是更为高效。
- **重量级锁**：适用于竞争激烈的情况，如果同步方法/代码块执行时间很长，那么使用轻量级自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。

