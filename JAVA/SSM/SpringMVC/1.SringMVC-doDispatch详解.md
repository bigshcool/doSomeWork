# SringMVC-doDispatch详解

## 1.请求处理大致流程

![image-20230420143321592](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230420143321592.png)

**前端控制器DispatcherServlet（不需要工程师开发）,由框架提供**，容器启动后，我们根据URL访问接口，DispatcherServlet的继承树如下:

![image-20230420143542323](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230420143542323.png)

由图可知`DispatcherServlet`继承自`HttpServlet`抽象类，我们的get/post请求分别会请求其`doGet`和`doPost`方法；

`DispatcherServlet`的父类`FrameworkServlet`中对`doGet`和`doPost`方法进行了重写，都会执行`this.processRequest(request, response)`;

```java
/*
* FrameworkServlet中的doGet方法和doPost方法
*/
protected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    this.processRequest(request, response);
}

protected final void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    this.processRequest(request, response);
}
```
`processRequest`方法会执行方法：`this.doService(request, response)`;而`FrameworkServlet`中的`doService`是抽象的，具体实现方法是在`DispatcherServlet`中；

```java
protected abstract void doService(HttpServletRequest request, HttpServletResponse response) throws Exception;
```

而`DispatcherServlet`中的`doService`则执行了关键方法：`this.doDispatch(request, response)`。

## 2.doDispatch方法详解

```java
 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        HttpServletRequest processedRequest = request;
        HandlerExecutionChain mappedHandler = null;
        boolean multipartRequestParsed = false;
        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
 
        try {
            try {
                ModelAndView mv = null;
                Object dispatchException = null;
 
                try {
                    //1,processedRequest意思为处理之后的请求，而它是由checkMultipart(request)方法处理的
                    // checkMulitipart判断是否是文件上传请求
                    processedRequest = this.checkMultipart(request);
                    multipartRequestParsed = processedRequest != request;
                 	//2,！！！ 获取request的Handler方法，handler被封装为HandlerExecutionChain，
                    //        简而言之就是找到由那个Controller处理
                    //        封装了Handler的HandlerExecutionChain对象并返回；
                    mappedHandler = this.getHandler(processedRequest);
                    // 如果没有找到对应的handler就会抛出异常，或者重定向到一个错误页面
                    if (mappedHandler == null || mappedHandler.getHandler() == null) {
                        this.noHandlerFound(processedRequest, response);
                        return;
                    }
                	//3，通过Handler(处理器，也就是Controller)获取方法的HandlerAdpater(适配器:反射工具)
                    //   Spring要通过反射执行这个方法
                    HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());
                    // 获得请求方式是get还收post
                    String method = request.getMethod();
                    boolean isGet = "GET".equals(method);
                    if (isGet || "HEAD".equals(method)) {
                        long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                        if (this.logger.isDebugEnabled()) {
                            this.logger.debug("Last-Modified value for [" + getRequestUri(request) + "] is: " + lastModified);
                        }
 
                        if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {
                            return;
                        }
                    }
					//4,Handler的预处理，还记得刚才返回的HandlerExecutionChain封装了Handler和一些拦截器，现在就是调用拦截器的时候。
                    if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                        return;
                    }
					//5, ！！！HandlerAdpater让Handler处理request与response，，真正执行业务方法，获取ModelAndView
                    //  	  将目标方法执行完成后的返回值作为视图名，设置保存到modelAndView，无论怎么写，最终适配器完成以后都会将执行后的信息封装成
                    //        ModelAndView，其中View的值就是视图解析器需要拼接的地址
                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
                    if (asyncManager.isConcurrentHandlingStarted()) {
                        return;
                    }
					//6,如果mv中返回内容没有view视图名，那么我就给你返回默认的视图名，也就是请求地址是什么，我的视图就是什么
                    this.applyDefaultViewName(processedRequest, mv);
					//7,这一步与前面的拦截器预处理类似。
                    mappedHandler.applyPostHandle(processedRequest, response, mv);
                } catch (Exception var20) {
                    dispatchException = var20;
                } catch (Throwable var21) {
                    dispatchException = new NestedServletException("Handler dispatch failed", var21);
                }
            	//8,处理请求分发的结果，转发到view中的页面，完成视图页面的渲染
                this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);
            } catch (Exception var22) {
                this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);
            } catch (Throwable var23) {
                this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", var23));
            }
 
        } finally {
            if (asyncManager.isConcurrentHandlingStarted()) {
                if (mappedHandler != null) {
                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
                }
            } else if (multipartRequestParsed) {
                this.cleanupMultipart(processedRequest);
            }
 
        }
    }
```

## 3. doDispatch()深入

1. **getHandler()**：根据当前请求地址找到能够处理这个请求的目标处理器(**是一个Controller**)
2. **getHandlerAdapter(mappedHandler.getHandler())**：根据但其概念处理器获取到能执行这个处理器方法的适配器。
3. 使用刚才取到的适配器(AnnotationMethodHandlerAdapter)执行目标方法
4. 目标方法执行后会返回一个ModelAndView对象
5. 根据ModelAndView的信息转发到具体的页面，并可以在请求域取出ModelAndView中的模型数据

### 3.1 getHandler()

**找到目标处理器的headler，也就是controller**

```java
@Nullable
protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    // 原生的request其中包括requestDispatcherPath = “/hello” 
    if (this.handlerMappings != null) 
        // HandlerMapping：处理器映射，他里面保存了每一个处理器处理哪些方法的映射
        //     BeanNameUrlHandlerMapping    配置HandlerMaping
        //     DefaultAnnotationHandlerMaping 注解HandlerMaping
        //         handlerMap = LinkedHashMap<K,V>
        //         比如: {/hello = com.atguigu.controller.HelloController@2C484979}
        // 整个for循环首先遍历，BeanNameUrlHandlerMapping
        // 然后遍历DefaultAnnotationHandlerMapping
        for (HandlerMapping mapping : this.handlerMappings) {
            HandlerExecutionChain handler = mapping.getHandler(request);
            if (handler != null) {
                return handler;
            }
        }
    }
    return null;
}
```

handlerMap：IOC容器启动创建Controller对象的时候扫描每个处理器都能处理什么请求，保存在HandllerMapping的handlerMap属性中，下次请求过来，就查看那个HandlerMapping有这个请求路径。

### 3.2 getHandlerAdapter()

找到适配器，找到对应Controller对象的对应方法。

```java
protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
    	// this.handlerAdapters:有三组适配器
    	//      HttpRequestHandlerAdapter
    	// 		SimpleControllerHandleAdapter
    	// 		AnnotationMethodHandlerAdapter : 能解析注解方法的适配器
		for (HandlerAdapter ha : this.handlerAdapters) {
			if (logger.isTraceEnabled()) {
				logger.trace("Testing handler adapter [" + ha + "]");
			}
            // 每组适配器的方式的support方法都不一样，AnnotationMethodHandlerAdapter就是判断处理器中是否有方法
			if (ha.supports(handler)) {
				return ha;
			}
		}
		throw new ServletException("No adapter for handler [" + handler +
				"]: Does your handler implement a supported interface like Controller?");
}
```

### 3.3 SpringMVC-9大组件(DispatcherServlet)

**SpringMVC在工作的时候，关键位置都是由这些组件构成的;**

- **MultipartResolver**:文件上传解析器

- **LocaleResolver：**区域信息解析器:国际化有关

- **ThemeResolver**：主题解析器

- **HandlerMappings**：handler映射信息

- **HandlerAdapters**：handler的适配器

- **HandlerExceptionResolver**：异常解析器

- **RequestToViewNameTranslator**：

  ViewName是根据ViewName查找View，但有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。

- **FlashMapManager**：运行SpringMVC中运行重定向携带数据的功能。

- **ViewResolver**: ViewResolver用来将String类型的视图名和Locale解析为View类型的视图

**以上组件全部都是接口，接口就是规范。**

#### 3.3.1 初始化九大组件

```java
/*
*  DispatcherServlet
*/
protected void initStrategies(ApplicationContext context) {
        this.initMultipartResolver(context);
        this.initLocaleResolver(context);
        this.initThemeResolver(context);
        this.initHandlerMappings(context);
        this.initHandlerAdapters(context);
        this.initHandlerExceptionResolvers(context);
        this.initRequestToViewNameTranslator(context);
        this.initViewResolvers(context);
        this.initFlashMapManager(context);
}
```

### 3.4 目标方法的执行

- 通过处理器的适配器已经找到了目标方法

```java
// Controller 如下
public String updateBook(@RequestParam(value = "author") String author,Map<String,Object> model,HttpServletRequest request,@ModelAttribute("haha") Book book)
```

- 通过执行目标方法

```java
// 执行目标方法
mv = ha.handle(processedRequest, Response, mappedHandler.getHandler());
```

- handle调用了以下方法

```java
return invokeHandlerMethod(request, response, handler);
```

- 针对具体方法进行参数的封装

  - 先确定modelattribute方法执行时要使用的每一个参数的值

    ```java
    Object [] args = resulveHandlerArguments(attributeMethodToInvoke,handler,webRequest,imlicticModel)
    ```

    - 通过attributeMethodToInvoker方法执行ModelAttribute方法

      ```java
      Object attrValue = attributeMethodToInvoke.invoke(handler, args);
      ```

      同时如果ModelAttribute如果没有返回值的话，就会将返回值进行首字母小写，并且加入到隐藏模型之中.

    - 在执行真正的方法之前**resolveHandlerArguments**还要还需要对目标方法参数解析

        ```java
      Object [] args = resolveHandlerArguments(handlerMethodToInvoke,hanbler,webRequest,implicitModel)
      ```

    - 通过handlerMethodToInvoke.invoke

      ```java
      handlerMethodToInvoke.invoke(handler, args)
      ```

  - **resolveHandlerArguments方法进行目标方法的参数确定**

    1. 首先会确定方法所有参数的参数类型

       ![image-20230422095256700](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230422095256700.png)

    2. 然后对注解信息进行获取

       - 如果注解信息是RequestParam.class

       ```java
       // 进行“author”变量的赋值
       paramName = requestParam.value();
       required = requestPararm.required();
       ```

       然后本质其实是调用了

       ```java
       String [] paramValues = WebRequest.getParameterValues(paramName)
       ```

       - 如果没有注解 && 并且传入的类型是Map或者Model就会将implicitModel传入，**注意此时的implicitModel就是之前确定初始化的**

       - 如果没有注解并且类型是HttpServletRequest此类原生API的话，就直接进行赋值

       - POJO参数的确定

         - 如果是有参数，是ModelAtribute注解
           - 拿到ModelAttribute注解的值让attrName保存，比如attrName = “haha
         - 如果自定义类型，没有注解
           - 先看是否是原生API
           - 然后再看你是否是Model还是Map
           - 再看是否是是SessionStatus，HttpEntity，Errors
           - 再看看是否是简单的属性，比如Integet，String之类的
           - atttName = ”“

         如果是自定义类型对象，只有可能产生两种情况，就是要么从ModelAttribute中获取，要么就是”“空串

         - 根据获取的attName进入resolveModelAttribute解析方法
           - 首先此方法会进行判断是否attrName为空，如果为”“空串，则将类型名的手写字母小写，然后将其赋值给name
           - 如果隐含模型中有这个name，作为key的value，则直接进行，此时应该指的是Book对象
           - 如果隐含模型中没有这个name，那么就会去找sessionAttribute，有没有这个name作为参数类型的
           - **如果还没找到对应的类型，那么就会通过反射机制创建一个对象**


## 4. 总结

- 首先获取请求对应的处理器Handler
- 然后获取请求对应的处理方法，也就是HandlerAdapter
- 使用了ModelAttribute注解，那么就要先一步在HandlerAdapter之前执行，从数据库拉取数据封装成对象，**注意此时注解的不是目标方法**
- 针对目标方法的参数进行解析
  - 标注解
    - 保存注解的信息;最终得到了这个注解对应解析的值
  - 没标注解
    - 看是否是原生API
    - 看看是否是Model或者Map
    - 都是不，看看是否是简单类型
    - 给attrName赋值；attrName(参数标了@ModelAttribute("")就是指定的，没标就是”“)
      - 确定自定义参数类型
        - attrwName使用参数的类型首字母小写;或者使用之前@ModelAttribute("")的值，将它们作为key
        - 先从隐藏模型查看有没有对应的值；如果有就从隐含模型中获取并且赋值
        - 看看是否是SessionAttributes是否有值；
        - 如果都不是，那么就是通过反射创建一个对象。
- 拿到之前创建好的对象，使用数据绑定器(WebDataBinder)将请求中的每个数据都绑定到这个对象中去。

参考链接
[SpringMVC源码解析-doDispatch方法 - 掘金 (juejin.cn)](https://juejin.cn/post/7112238139724267551)
[(193条消息) DispatcherServlet.java 的doDispatch方法详解_forrestGTJU的博客-CSDN博客](https://blog.csdn.net/forrestGTJU/article/details/100121097)

