# SpringMVC视图解析

SpringMVC视图解析

1. 方法执行后的返回值会作为页面地址参考，转发后者重定向到页面
2. 视图解析器可能会进行页面地址的拼串.



## 1.视图解析的核心方法

1. 任何方法的返回值，最终都会被包装成ModelAndView对象

```java
mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
```

![image-20230422172834201](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230422172834201.png)

2. 转发或者重定向到页面.

```java
processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
```

渲染视图流程：将域中的数据在页面进行展示;页面就是用来渲染模型数据的

3. 调用processDispatchResult中render方法.
4. View和ViewResolver;
   - ViewResolver的作用是根据视图名（返回值）得到View对象
5. resolveViewName()方法
6. AbstractCachingViewResolver的resolveViewName方法

**视图解析器只是为了得到视图对象;只有视图对象才能真正的转发或者重定向（将模型数据全部放在请求域中）到页面.视图对象才能真正的渲染视图。**

## 2. 查看processDispatchResult方法

```java
private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
      HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception {

   boolean errorView = false;

   if (exception != null) {
      if (exception instanceof ModelAndViewDefiningException) {
         logger.debug("ModelAndViewDefiningException encountered", exception);
         mv = ((ModelAndViewDefiningException) exception).getModelAndView();
      }
      else {
         Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
         mv = processHandlerException(request, response, handler, exception);
         errorView = (mv != null);
      }
   }

   // Did the handler return a view to render?
   if (mv != null && !mv.wasCleared()) {
      // !!! 渲染代码
      render(mv, request, response);
      if (errorView) {
         WebUtils.clearErrorRequestAttributes(request);
      }
   }
   else {
      if (logger.isDebugEnabled()) {
         logger.debug("Null ModelAndView returned to DispatcherServlet with name '" + getServletName() +
               "': assuming HandlerAdapter completed request handling");
      }
   }

   if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
      // Concurrent handling started during a forward
      return;
   }

   if (mappedHandler != null) {
      mappedHandler.triggerAfterCompletion(request, response, null);
   }
}
```

## 3.render方法

```java
protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {
   // Determine locale for request and apply it to the response.
   Locale locale = this.localeResolver.resolveLocale(request);
   response.setLocale(locale);

   View view;
   if (mv.isReference()) {
      // We need to resolve the view name.
      view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);
      if (view == null) {
         throw new ServletException("Could not resolve view with name '" + mv.getViewName() +
               "' in servlet with name '" + getServletName() + "'");
      }
   }
   else {
      // No need to lookup: the ModelAndView object contains the actual View object.
      view = mv.getView();
      if (view == null) {
         throw new ServletException("ModelAndView [" + mv + "] neither contains a view name nor a " +
               "View object in servlet with name '" + getServletName() + "'");
      }
   }

   // Delegate to the View object for rendering.
   if (logger.isDebugEnabled()) {
      logger.debug("Rendering view [" + view + "] in DispatcherServlet with name '" + getServletName() + "'");
   }
   try {
      view.render(mv.getModelInternal(), request, response);
   }
   catch (Exception ex) {
      if (logger.isDebugEnabled()) {
         logger.debug("Error rendering view [" + view + "] in DispatcherServlet with name '" +
               getServletName() + "'", ex);
      }
      throw ex;
   }
}
```

## 4.resolveViewName

```java
protected View resolveViewName(String viewName, Map<String, Object> model, Locale locale,
      HttpServletRequest request) throws Exception {
   // 遍历所有的视图解析器
   for (ViewResolver viewResolver : this.viewResolvers) {
       // ViewResolver视图解析器根据方法的返回值，得到一个View对象
       // 如果有多种视图解析器，就进行视图解析，直到得到一个View，则进行返回
      View view = viewResolver.resolveViewName(viewName, locale);
      if (view != null) {
         return view;
      }
   }
   return null;
}
```

## 5.AbstractCachingViewResolver的resolveViewName

```java
public View resolveViewName(String viewName, Locale locale) throws Exception {
   if (!isCache()) {
      return createView(viewName, locale);
   }
   else {
      Object cacheKey = getCacheKey(viewName, locale);
      View view = this.viewAccessCache.get(cacheKey);
      if (view == null) {
         synchronized (this.viewCreationCache) {
            view = this.viewCreationCache.get(cacheKey);
            if (view == null) {
               // Ask the subclass to create the View object.
               // ！！！创建视图
               view = createView(viewName, locale);
               if (view == null && this.cacheUnresolved) {
                  view = UNRESOLVED_VIEW;
               }
               if (view != null) {
                  this.viewAccessCache.put(cacheKey, view);
                  this.viewCreationCache.put(cacheKey, view);
                  if (logger.isTraceEnabled()) {
                     logger.trace("Cached view [" + cacheKey + "]");
                  }
               }
            }
         }
      }
      return (view != UNRESOLVED_VIEW ? view : null);
   }
}
```

## 6.createView

```java
protected View createView(String viewName, Locale locale) throws Exception {
   // If this resolver is not supposed to handle the given view,
   // return null to pass on to the next resolver in the chain.
   if (!canHandle(viewName, locale)) {
      return null;
   }
   // Check for special "redirect:" prefix.
   if (viewName.startsWith(REDIRECT_URL_PREFIX)) {
      String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());
      RedirectView view = new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible());
      return applyLifecycleMethods(viewName, view);
   }
   // Check for special "forward:" prefix.
   if (viewName.startsWith(FORWARD_URL_PREFIX)) {
      String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());
      return new InternalResourceView(forwardUrl);
   }
   // Else fall back to superclass implementation: calling loadView.
   return super.createView(viewName, locale);
}
```

## 7. 视图解析器相关概念

![image-20230422222830967](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230422222830967.png)

无论返回值是String，是ModelAndView或者ModelAndView都会生成ModelAndView对象，然后经过视图解析器，解析形成视图对象。**视图对象是由视图解析器负责实例化。由于视图是无状态的，所以它们不会有线程安全的问题。**

- 常见的视图类型

![image-20230422223643369](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230422223643369.png)

- 常见的视图解析器

  - SpringMVC为逻辑视图名的解析提供不同的策略，并且可以在Spring WEB上下文中配置一种或者多种解析策略，并且指定他们之间的先后顺序。每种映射策略对应一个具体的视图解析实现类。

  - 视图解析器的作用比较单一:将逻辑视图解析为一个具体的视图对象。

  - 所有的视图解析器都必须实现ViewResolver接口

    - 程序员可以选择一种解析器或或者混用多种视图解析器
    - 每个视图解析器都实现了Order属性指定解析器的先后顺序，order越小优先级越高
    - Spring MVC会按照视图解析器的顺序有限顺序对逻辑视图进行解析，直到解析成功

    ```java
    resolveViewName(String, Locale) : View
    ```

![image-20230422224139401](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230422224139401.png)

​	



​             