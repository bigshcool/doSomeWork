# Spring事务

## 1.Spring事务

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/tx
       https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!--从classpath的根路径去加载db.properties文件-->
    <!--<context:property-placeholder location="classpath:db.properties" system-properties-mode="NEVER"/>-->
    <context:property-placeholder location="classpath:db.properties"/>

    <!--配置一个druid的连接池-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
          init-method="init" destroy-method="close">
        <property name="driverClassName" value="${jdbc.driverClassName}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
        <property name="initialSize" value="${jdbc.initialSize}"/>
    </bean>

    <!--配置dao-->
    <bean id = "accountDao" class="com.sunny.dao.impl.AccountDaoImpl">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <!-- 1: 配置JDBC事务管理器 WHAT:做什么增强(这里做事务增强)-->
    <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!-- 2: 配置事务管理器增强 WHEN-->
    <tx:annotation-driven id="txAdvice" transaction-manager="txManager" />
</beans>

```

## 2.Spring的Transactional注解的值

| 参数                   | 意义                                             |
| ---------------------- | ------------------------------------------------ |
| isolation              | 事务隔离级别，默认为DEFAULT                      |
| propagation            | 事务传播机制，默认为REQUIRED                     |
| readOnly               | 事务读写性，默认为false                          |
| noRollbackFor          | 一组异常类，遇到时不回滚，默认为{}               |
| noRollbackForClassName | 一组异常类名，遇到时不回滚，默认为{}             |
| rollbackFor            | 一组异常类，遇到时回滚，默认为{}                 |
| rollbackForClassName   | 一组异常类名，遇到时回滚，默认为{}               |
| timeout                | 超时时间，以秒为单位                             |
| value                  | 可选的限定描述符，指定使用的事务管理器，默认为“” |

### 2.1 timeout

用于设置事务处理的时间长度，阻止可能出现的长时间的阻塞系统或者占用系统资源，单位为秒。

如果超时设置事务回滚，并抛出TransactionTimedOutException异常。



### 2.2 readOnly（事务读写性）

默认情况下是 false（即：不指定只读性），设置为 true 的含义是： 告诉程序该方法下使用的是只读操作，如果进行其他非读操作，则会抛出异常。

- **应用场景**
  - 如果你一次执行**单条**查询语句，则没有必要启用事务的只读性支持，数据库默认支持SQL执行期间的读一致性；
  - 如果你一次执行**多条**查询语句，例如统计查询，报表查询。在这种场景下，多条查询SQL必须保证整体的读一致性，否则，在前条SQL查询之后，后条SQL查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态。此时，就有必要启用事务的只读性支持。



### 2.3 noRollbackFor

- 默认情况

  Spring默认情况下会对运行期异常（RunTimeException）进行事务回滚，如果遇到checked异常就不回滚。

  - 异常分类
    - 运行时异常(非检查异常)，可以不做处理，默认都回滚
    - 编译时异常(检查异常)，要么可以try-catch，要么在方法上声明throws

- 要需要回滚的不进行回滚

```java
@Transactional(noRollbackFor={ArithmeicException.class,NullPointerException.class})
```



### 2.4 rollbackFor

让编译时异常进行回滚

```java
@Transactional(RollbackFor={FileNotFoundException.class})
```



### 2.5 isolation

#### 2.5.1 数据库路事务并发问题

假设现在有两个事务:Transaction01和Transaction02并发执行。

- 脏读
  1. Transaction01将某条记录的AGE从20修改成了30
  2. Transaction02读取了Transaction01更新后的值30
  3. Transaction01回滚，AGE值恢复到了20
  4. Transaction02读取到的30就是一个无效值
- 不可重复读
  1. Transaction01读取了AGE值为20
  2. Transaction02将AGE值修改为30
  3. Transaction01再次读取AGE值为30，发现和第一次读取的值不一样。
- 幻读
  1. Transaction01读取了STUDENT表中的一部分数据
  2. Transaction02向STUDENT表中插入了新数据
  3. Transaction01读取STUDENT表发现多了一行数据。

#### 2.5.2 隔离级别

数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题，**一个事务与其他事务隔离的程度成为隔离级别**。SQL表标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但是并发能力越弱。

- 读未提交：**READ UNCOMMITTED**

  允许Transaction01读取Transaction02未提交的内容，**无法杜绝脏读的情况**

  ![image-20230417210000239](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230417210000239.png)

- 读已提交:  **READ COMMITTED**

  允许Transaction01只能读取Transaction02已提交的数据， **可以完成脏读杜绝，但是无法解决不可重复读和幻读**

  ![image-20230417210355075](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230417210355075.png)

- 可重复读: **REPEATABLE READ （MySQL默认的隔离级别）**

  确保Transaction01可以多次从一个字段中读取相同的值，即Transaction01执行期间禁止其他事务对这个字段进行跟新，**可以杜绝脏读和不可重复读，但是不能杜绝幻读**。

  ![image-20230417210731548](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230417210731548.png)

- 串行化： **SERALIZABLE**

  确保Transaction01可以多从从一个表中读取到相同的行，在Transaction01执行期间，禁止其他事务对这个表进行增添,更新，删除操作。可以避免任何并发问题，但是性能十分低下。

**IOC容器中保存的是业务逻辑组件(有事务)的代理对象，同时以上的针对于出现的数据并发问题，都是针对于有读有写的问腿，但是针对于都是写操作的时候，都会默认排队，只有上个事务进行commit以后，下一个事务才能继续修改。**

![image-20230417211557698](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230417211557698.png)

### 2.6 propagation-Propagation: 事务的传播行为

传播行为（事务的传播+事务的行为）

事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。 
例如：methodA事务方法调用methodB事务方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。

- Spring七种传播行为

![image-20230418220601555](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230418220601555.png)

#### 2.6.1 PROPAGATION_REQUIRED

如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 
可以把事务想像成一个胶囊，在这个场景下方法B用的是方法A产生的胶囊（事务）。 

![image-20230418220729424](https://raw.githubusercontent.com/bigshcool/myPic/main/image-20230418220729424.png)

```java
@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
 methodB();
// do something
}
 
@Transactional(propagation = Propagation.REQUIRED)
public void methodB() {
    // do something
}
```

单独调用methodB方法时，因为当前上下文不存在事务，所以会开启一个新的事务。 
调用methodA方法时，因为当前上下文不存在事务，所以会开启一个新的事务。当执行到methodB时，methodB发现当前上下文有事务，因此就加入到当前事务中来。

**同时如果有一个大事务将methodA与methodB包裹起来，那么就是由大事务的属性值有效，其他的无效**

- REQUIRED:将之前的事务用的connection传递给这个方法使用
- REQUIRES_NEW:这个方法直接使用新的connection

**如果是本类事务方法中调用其他本类事务方法，即便是使用了REQUIRED_NEW那么也会被当作同一个事务，本质上是没有通过代理对象来调用事务方法**